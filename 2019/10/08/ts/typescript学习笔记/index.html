<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"swiftist.cn","root":"/","scheme":"Pisces","version":"7.7.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"EVBR3H53HW","apiKey":"2abd573a01143a0cc4108fa4d21ae67c","indexName":"swiftist","hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 要点1.1. 为什么要使用Typescript 是由微软开发的一款开源的编程语言，Typescript 是 JavaScript 的超集，遵循最新的 ES6、ES5 规范，Typescript 扩展了 JavaScript 的语法，Typescript 更像后端 java、C# 这样的面向对象语言 可以让 JavaScript 开发大型企业项目。 它提供先进的自动完成、导航和重构工具，而以上">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript学习笔记">
<meta property="og:url" content="https://swiftist.cn/2019/10/08/ts/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="飞雪轩辕">
<meta property="og:description" content="1. 要点1.1. 为什么要使用Typescript 是由微软开发的一款开源的编程语言，Typescript 是 JavaScript 的超集，遵循最新的 ES6、ES5 规范，Typescript 扩展了 JavaScript 的语法，Typescript 更像后端 java、C# 这样的面向对象语言 可以让 JavaScript 开发大型企业项目。 它提供先进的自动完成、导航和重构工具，而以上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://swiftist.cn/images/es/tscheck.gif">
<meta property="og:image" content="https://swiftist.cn/2019/10/08/images/ts/WX20191123-060355@2x.png">
<meta property="article:published_time" content="2019-10-08T07:03:13.000Z">
<meta property="article:modified_time" content="2020-03-31T15:07:39.448Z">
<meta property="article:author" content="Andy Ge">
<meta property="article:tag" content="typescript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://swiftist.cn/images/es/tscheck.gif">

<link rel="canonical" href="https://swiftist.cn/2019/10/08/ts/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>typescript学习笔记 | 飞雪轩辕</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="飞雪轩辕" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">飞雪轩辕</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">人生的乐趣在于把梦想变成现实</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-java">

    <a href="/categories/java/" rel="section"><i class="fa fa-fw fa-th-large"></i>java</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://swiftist.cn/2019/10/08/ts/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Andy Ge">
      <meta itemprop="description" content="勇于积极进取，步入人生的世外桃源">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="飞雪轩辕">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          typescript学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-10-08 15:03:13" itemprop="dateCreated datePublished" datetime="2019-10-08T15:03:13+08:00">2019-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-03-31 23:07:39" itemprop="dateModified" datetime="2020-03-31T23:07:39+08:00">2020-03-31</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index">
                    <span itemprop="name">typescript</span>
                  </a>
                </span>
            </span>

          
            <span id="/2019/10/08/ts/typescript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-meta-item leancloud_visitors" data-flag-title="typescript学习笔记" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-要点"><a href="#1-要点" class="headerlink" title="1. 要点"></a>1. 要点</h1><h2 id="1-1-为什么要使用"><a href="#1-1-为什么要使用" class="headerlink" title="1.1. 为什么要使用"></a>1.1. 为什么要使用</h2><p>Typescript 是由微软开发的一款开源的编程语言，Typescript 是 JavaScript 的超集，遵循最新的 ES6、ES5 规范，Typescript 扩展了 JavaScript 的语法，Typescript 更像后端 java、C# 这样的面向对象语言 可以让 JavaScript 开发大型企业项目。</p>
<p>它提供先进的<code>自动完成</code>、<code>导航</code>和<code>重构工具</code>，而以上工具，几乎完全满足了大型项目的需求。没有他们的话，对于修改代码的恐惧会将代码置于半只读的状态，并且使大规模的重构非常危险和昂贵。<br>大量重量级前端开源项目采用 TypeScript 开发，例如：Angular、VScode、Vue3.0、Rxjs、TypeScript、Mobx、deno、Antd,这个趋势越来越明显，包括 Facebook 自家的 Jest 也宣布从 flow Type 转向 TypeScript。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> IPriceProps &#123;</span><br><span class="line">    num: <span class="built_in">number</span></span><br><span class="line">    symbol: <span class="string">'$'</span> | <span class="string">'€'</span> | <span class="string">'£'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Price: React.SFC&lt;IPriceProps&gt; = <span class="function">(<span class="params">&#123; num, symbol &#125;: IPriceProps</span>) =&gt;</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;&#123;<span class="string">`<span class="subst">$&#123;symbol&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/h3&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LabelPrice = <span class="function"><span class="params">()</span> =&gt;</span> &lt;Price num=&#123;<span class="number">123</span>&#125; symbol=<span class="string">"$"</span> /&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>类型检查和智能提示<br><img src="/images/es/tscheck.gif" alt=""></p>
<h2 id="1-2-基础类型"><a href="#1-2-基础类型" class="headerlink" title="1.2. 基础类型"></a>1.2. 基础类型</h2><p>为了让程序有价值，我们需要能够处理最简单的数据单元：<code>string</code>,<code>boolean</code>,<code>number</code>,<code>symbol</code>等。 TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p>
<h3 id="1-2-1-布尔值"><a href="#1-2-1-布尔值" class="headerlink" title="1.2.1. 布尔值"></a>1.2.1. 布尔值</h3><p>最基本的数据类型就是简单的 true/false 值，在 JavaScript 和 TypeScript 里叫做<code>boolean</code>（其它语言中也一样）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-数字"><a href="#1-2-2-数字" class="headerlink" title="1.2.2. 数字"></a>1.2.2. 数字</h3><p>和 JavaScript 一样，TypeScript 里的所有数字都是浮点数。 这些浮点数的类型是<code>number</code>。 除了支持十进制和十六进制字面量，TypeScript 还支持 ECMAScript 2015 中引入的二进制和八进制字面量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-字符串"><a href="#1-2-3-字符串" class="headerlink" title="1.2.3. 字符串"></a>1.2.3. 字符串</h3><p>JavaScript 程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用<code>string</code>表示文本数据类型。 和 JavaScript 一样，可以使用双引号（``）或单引号（<code>&#39;</code>）表示字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'bob'</span></span><br><span class="line">name = <span class="string">'smith'</span></span><br></pre></td></tr></table></figure>

<p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围，并且以<code>${ expr }</code>这种形式嵌入表达式</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span></span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span></span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123;name&#125;</span>.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I'll be <span class="subst">$&#123;age + <span class="number">1</span>&#125;</span> years old next month.`</span></span><br></pre></td></tr></table></figure>

<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> =</span><br><span class="line">    <span class="string">'Hello, my name is '</span> +</span><br><span class="line">    name +</span><br><span class="line">    <span class="string">'.\n\n'</span> +</span><br><span class="line">    <span class="string">"I'll be "</span> +</span><br><span class="line">    (age + <span class="number">1</span>) +</span><br><span class="line">    <span class="string">' years old next month.'</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-4-数组"><a href="#1-2-4-数组" class="headerlink" title="1.2.4. 数组"></a>1.2.4. 数组</h3><p>TypeScript 像 JavaScript 一样可以操作数组元素。 有两种方式可以定义数组。</p>
<ul>
<li>第一种，可以在元素类型后面接上<code>[]</code>，表示由此类型元素组成的一个数组：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>第二种方式是使用数组泛型，<code>Array&lt;元素类型&gt;</code>：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="1-2-5-元组-Tuple"><a href="#1-2-5-元组-Tuple" class="headerlink" title="1.2.5. 元组 Tuple"></a>1.2.5. 元组 Tuple</h3><p>元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为<code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>]</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">'hello'</span>, <span class="number">10</span>] <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">'hello'</span>] <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)) <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)) <span class="comment">// Error, 'number' does not have 'substr'</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-6-Any"><a href="#1-2-6-Any" class="headerlink" title="1.2.6. Any"></a>1.2.6. Any</h3><p>有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用<code>any</code>类型来标记这些变量：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure = <span class="string">'maybe a string instead'</span></span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>

<p><strong>Any 和 Object 的区别</strong></p>
<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为<code>Object</code>有相似的作用，就像它在其它语言中那样。 但是<code>Object</code>类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span></span><br><span class="line">notSure.ifItExists() <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed() <span class="comment">// okay, toFixed exists (but the compiler doesn't check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span></span><br><span class="line">prettySure.toFixed() <span class="comment">// Error: Property 'toFixed' doesn't exist on type 'Object'.</span></span><br><span class="line">;(&lt;<span class="built_in">number</span>&gt;prettySure).toFixed()</span><br></pre></td></tr></table></figure>

<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">'free'</span>]</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-7-Void"><a href="#1-2-7-Void" class="headerlink" title="1.2.7. Void"></a>1.2.7. Void</h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是<code>void</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'This is my warning message'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>null</code>（只有当<code>--strictNullChecks</code>未指定时才可以）和<code>undefined</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-8-Null-和-Undefined"><a href="#1-2-8-Null-和-Undefined" class="headerlink" title="1.2.8. Null 和 Undefined"></a>1.2.8. Null 和 Undefined</h3><p>TypeScript 里，<code>undefined</code>和<code>null</code>两者各自有自己的类型分别叫做<code>undefined</code>和<code>null</code>。和<code>void</code>相似，它们的本身的类型用处不是很大：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Not much else we can assign to these variables!</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>默认情况下<code>null</code>和<code>undefined</code>是所有类型的子类型。 就是说你可以把<code>null</code>和<code>undefined</code>赋值给<code>number</code>类型的变量。</p>
<p>然而，当你指定了<code>--strictNullChecks</code>标记，<code>null</code>和<code>undefined</code>只能赋值给<code>void</code>和它们各自。这能避免<em>很多</em>常见的问题。 也许在某处你想传入一个<code>string</code>或<code>null</code>或<code>undefined</code>，你可以使用联合类型<code>string | null | undefined</code>。再次说明，稍后我们会介绍联合类型。</p>
<h3 id="1-2-9-Never"><a href="#1-2-9-Never" class="headerlink" title="1.2.9. Never"></a>1.2.9. Never</h3><p><code>never</code>类型表示的是那些永不存在的值的类型。 例如，<code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是<code>never</code>类型，当它们被永不为真的类型保护所约束时。</p>
<p><code>never</code>类型是任何类型的子类型，也可以赋值给任何类型；然而，<em>没有</em>类型是<code>never</code>的子类型或可以赋值给<code>never</code>类型（除了<code>never</code>本身之外）。即使<code>any</code>也不可以赋值给<code>never</code>。</p>
<p>下面是一些返回<code>never</code>类型的函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 推断的返回值类型为never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">'Something failed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回never的函数必须存在无法达到的终点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">infiniteLoop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-10-Object"><a href="#1-2-10-Object" class="headerlink" title="1.2.10. Object"></a>1.2.10. Object</h3><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的 API。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object | <span class="literal">null</span></span>): <span class="title">void</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">&#123; prop: 0 &#125;</span>) // <span class="title">OK</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">null</span></span>) // <span class="title">OK</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">42</span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params">'<span class="built_in">string</span>'</span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">false</span></span>) // <span class="title">Error</span></span></span><br><span class="line"><span class="function"><span class="title">create</span>(<span class="params"><span class="literal">undefined</span></span>) // <span class="title">Error</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-11-Symbol"><a href="#1-2-11-Symbol" class="headerlink" title="1.2.11. Symbol"></a>1.2.11. Symbol</h3><p><code>symbol</code>类型的值是通过<code>Symbol</code>构造函数创建的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym1 = Symbol()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sym2 = Symbol(<span class="string">'key'</span>) <span class="comment">// 可选的字符串key</span></span><br></pre></td></tr></table></figure>

<p>Symbols 是不可改变且唯一的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym2 = Symbol(<span class="string">'key'</span>)</span><br><span class="line"><span class="keyword">let</span> sym3 = Symbol(<span class="string">'key'</span>)</span><br><span class="line"></span><br><span class="line">sym2 === sym3 <span class="comment">// false, symbols是唯一的</span></span><br></pre></td></tr></table></figure>

<p>像字符串一样，symbols 也可以被用做对象属性的键。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = Symbol()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [sym]: <span class="string">'value'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj[sym]) <span class="comment">// "value"</span></span><br></pre></td></tr></table></figure>

<p>Symbols 也可以与计算出的属性名声明相结合来声明对象的属性和类成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getClassNameSymbol = Symbol()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    [getClassNameSymbol]() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'C'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line"><span class="keyword">let</span> className = c[getClassNameSymbol]() <span class="comment">// "C"</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-Enum-枚举"><a href="#1-3-Enum-枚举" class="headerlink" title="1.3. Enum 枚举"></a>1.3. Enum 枚举</h2><h3 id="1-3-1-数字枚举"><a href="#1-3-1-数字枚举" class="headerlink" title="1.3.1. 数字枚举"></a>1.3.1. 数字枚举</h3><p><code>enum</code>类型是对 JavaScript 标准数据类型的一个补充。 像 C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>

<p>默认情况下，从<code>0</code>开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从<code>1</code>开始编号：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>

<p>或者，全部都采用手动赋值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c: Color = Color.Green</span><br></pre></td></tr></table></figure>

<p>枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为 2，但是不确定它映射到 Color 里的哪个名字，我们可以查找相应的名字：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green,</span><br><span class="line">    Blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> colorName: <span class="built_in">string</span> = Color[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(colorName) <span class="comment">// 显示'Green'因为上面代码里它的值是2</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-2-字符串枚举"><a href="#1-3-2-字符串枚举" class="headerlink" title="1.3.2. 字符串枚举"></a>1.3.2. 字符串枚举</h3><p>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">'UP'</span>,</span><br><span class="line">    Down = <span class="string">'DOWN'</span>,</span><br><span class="line">    Left = <span class="string">'LEFT'</span>,</span><br><span class="line">    Right = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-3-异构枚举"><a href="#1-3-3-异构枚举" class="headerlink" title="1.3.3. 异构枚举"></a>1.3.3. 异构枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">'YES'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-4-联合枚举与枚举成员的类型"><a href="#1-3-4-联合枚举与枚举成员的类型" class="headerlink" title="1.3.4. 联合枚举与枚举成员的类型"></a>1.3.4. <code>联合枚举与枚举成员</code>的类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle</span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: ShapeKind.Square</span><br><span class="line">    sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Square,</span><br><span class="line">    <span class="comment">//    ~~~~~~~~~~~~~~~~ Error!</span></span><br><span class="line">    radius: <span class="number">100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Circle</code>的类型实际上是<code>ShapeKind&amp;ShapeKind.Circle</code>。</p>
<h3 id="1-3-5-反向映射"><a href="#1-3-5-反向映射" class="headerlink" title="1.3.5. 反向映射"></a>1.3.5. 反向映射</h3><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了<em>反向映射</em>，从枚举值到枚举名字。 例如，在下面的例子中：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a] <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 可能会将这段代码编译为下面的 JavaScript：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Enum</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">Enum</span>) </span>&#123;</span><br><span class="line">    Enum[(Enum[<span class="string">'A'</span>] = <span class="number">0</span>)] = <span class="string">'A'</span></span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> a = Enum.A</span><br><span class="line"><span class="keyword">var</span> nameOfA = Enum[a] <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure>

<p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（<code>name</code> -&gt;<code>value</code>）和反向映射（<code>value</code> -&gt;<code>name</code>）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p>
<p>要注意的是<em>不会</em>为字符串枚举成员生成反向映射。</p>
<h3 id="1-3-6-常量枚举"><a href="#1-3-6-常量枚举" class="headerlink" title="1.3.6. 常量枚举"></a>1.3.6. 常量枚举</h3><p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用<code>const</code>枚举。 常量枚举通过在枚举上使用<code>const</code>修饰符来定义。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [</span><br><span class="line">    Directions.Up,</span><br><span class="line">    Directions.Down,</span><br><span class="line">    Directions.Left,</span><br><span class="line">    Directions.Right</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>生成后的代码为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>]</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Interface-接口"><a href="#1-4-Interface-接口" class="headerlink" title="1.4. Interface 接口"></a>1.4. Interface 接口</h2><p><code>鸭式辨型</code>来自于 James Whitecomb Riley 的名言：”像鸭子一样走路并且嘎嘎叫的就叫鸭子。”。</p>
<p>TypeScript 的核心原则之一是对值所具有的<code>结构进行类型检查</code>。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。</p>
<h3 id="1-4-1-简单类型"><a href="#1-4-1-简单类型" class="headerlink" title="1.4.1. 简单类型"></a>1.4.1. 简单类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">    label: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(labelledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; size: <span class="number">10</span>, label: <span class="string">'Size 10 Object'</span> &#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-函数类型"><a href="#1-4-2-函数类型" class="headerlink" title="1.4.2. 函数类型"></a>1.4.2. 函数类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString)</span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-3-可索引的类型"><a href="#1-4-3-可索引的类型" class="headerlink" title="1.4.3. 可索引的类型"></a>1.4.3. 可索引的类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray</span><br><span class="line">myArray = [<span class="string">'Bob'</span>, <span class="string">'Fred'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="1-4-4-类接口"><a href="#1-4-4-类接口" class="headerlink" title="1.4.4. 类接口"></a>1.4.4. 类接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>): ClockInterface</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    tick(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createClock</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    ctor: ClockConstructor,</span></span></span><br><span class="line"><span class="function"><span class="params">    hour: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    minute: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ctor(hour, minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'beep beep'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick tock'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> digital = createClock(DigitalClock, <span class="number">12</span>, <span class="number">17</span>)</span><br><span class="line"><span class="keyword">let</span> analog = createClock(AnalogClock, <span class="number">7</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-4-5-接口继承"><a href="#1-4-5-接口继承" class="headerlink" title="1.4.5. 接口继承"></a>1.4.5. 接口继承</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br><span class="line">square.penWidth = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-6-混合类型"><a href="#1-4-6-混合类型" class="headerlink" title="1.4.6. 混合类型"></a>1.4.6. 混合类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">    interval: <span class="built_in">number</span></span><br><span class="line">    reset(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span>(<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line">    counter.interval = <span class="number">123</span></span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter()</span><br><span class="line">c(<span class="number">10</span>)</span><br><span class="line">c.reset()</span><br><span class="line">c.interval = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-7-接口重载"><a href="#1-4-7-接口重载" class="headerlink" title="1.4.7. 接口重载"></a>1.4.7. 接口重载</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Overloaded &#123;</span><br><span class="line">    (foo: <span class="built_in">string</span>): <span class="built_in">string</span></span><br><span class="line">    (foo: <span class="built_in">number</span>): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口的一个例子：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">number</span></span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">string</span></span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">stringOrNumber</span>(<span class="params">foo: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> foo === '<span class="built_in">number</span>'</span>) </span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">foo</span> * <span class="title">foo</span></span></span><br><span class="line"><span class="function">    &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> foo === '<span class="built_in">string</span>'</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`hello <span class="subst">$&#123;foo&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> overloaded: Overloaded = stringOrNumber</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">const</span> str = overloaded(<span class="string">''</span>) <span class="comment">// str 被推断为 'string'</span></span><br><span class="line"><span class="keyword">const</span> num = overloaded(<span class="number">123</span>) <span class="comment">// num 被推断为 'number'</span></span><br></pre></td></tr></table></figure>

<h2 id="1-5-Class-类"><a href="#1-5-Class-类" class="headerlink" title="1.5. Class 类"></a>1.5. Class 类</h2><h3 id="1-5-1-基本例子"><a href="#1-5-1-基本例子" class="headerlink" title="1.5.1. 基本例子"></a>1.5.1. 基本例子</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> greeter = <span class="keyword">new</span> Greeter(<span class="string">'world'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-2-继承"><a href="#1-5-2-继承" class="headerlink" title="1.5.2. 继承"></a>1.5.2. 继承</h3><p>如果有构造函数，子类务必调用基类的构造函数<code>super</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Snake <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Slithering...'</span>)</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Horse <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters = <span class="number">45</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Galloping...'</span>)</span><br><span class="line">        <span class="keyword">super</span>.move(distanceInMeters)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sam = <span class="keyword">new</span> Snake(<span class="string">'Sammy the Python'</span>)</span><br><span class="line"><span class="keyword">let</span> tom: Animal = <span class="keyword">new</span> Horse(<span class="string">'Tommy the Palomino'</span>)</span><br><span class="line"></span><br><span class="line">sam.move()</span><br><span class="line">tom.move(<span class="number">34</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-3-private"><a href="#1-5-3-private" class="headerlink" title="1.5.3. private"></a>1.5.3. private</h3><p>当成员被标记成<code>private</code>时，它就不能在声明它的类的外部访问，但是需要显示的标注，默认为<code>public</code>。比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Animal(<span class="string">'Cat'</span>).name <span class="comment">// 错误: 'name' 是私有的.</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-4-protected"><a href="#1-5-4-protected" class="headerlink" title="1.5.4. protected"></a>1.5.4. protected</h3><p><code>protected</code>修饰符与<code>private</code>修饰符的行为很相似，但有一点不同，<code>protected</code>成员在派生类中仍然可以访问。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.department = department</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'Howard'</span>, <span class="string">'Sales'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(howard.getElevatorPitch())</span><br><span class="line"><span class="built_in">console</span>.log(howard.name) <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>注意，我们不能在<code>Person</code>类外使用<code>name</code>，但是我们仍然可以通过<code>Employee</code>类的实例方法访问，因为<code>Employee</code>是由<code>Person</code>派生而来的。</p>
<h3 id="1-5-5-readonly"><a href="#1-5-5-readonly" class="headerlink" title="1.5.5. readonly"></a>1.5.5. readonly</h3><p>你可以使用<code>readonly</code>关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span></span><br><span class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">'Man with the 8 strong legs'</span>)</span><br><span class="line">dad.name = <span class="string">'Man with the 3-piece suit'</span> <span class="comment">// 错误! name 是只读的.</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-6-存取器"><a href="#1-5-6-存取器" class="headerlink" title="1.5.6. 存取器"></a>1.5.6. 存取器</h3><p>下面的例子中，<code>fullName</code>可以随意修改：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    fullName: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用存取器，只有授权以后才可以修改：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error: Unauthorized update of employee!'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-7-静态属性"><a href="#1-5-7-静态属性" class="headerlink" title="1.5.7. 静态属性"></a>1.5.7. 静态属性</h3><p>静态属性定义在类上，通过类名称来调用。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Grid &#123;</span><br><span class="line">    <span class="keyword">static</span> origin = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span><br><span class="line">    calculateDistanceFromOrigin(point: &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;) &#123;</span><br><span class="line">        <span class="keyword">let</span> xDist = point.x - Grid.origin.x</span><br><span class="line">        <span class="keyword">let</span> yDist = point.y - Grid.origin.y</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(xDist * xDist + yDist * yDist) / <span class="keyword">this</span>.scale</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> scale: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> grid1 = <span class="keyword">new</span> Grid(<span class="number">1.0</span>) <span class="comment">// 1x scale</span></span><br><span class="line"><span class="keyword">let</span> grid2 = <span class="keyword">new</span> Grid(<span class="number">5.0</span>) <span class="comment">// 5x scale</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(grid1.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;))</span><br><span class="line"><span class="built_in">console</span>.log(grid2.calculateDistanceFromOrigin(&#123; x: <span class="number">10</span>, y: <span class="number">10</span> &#125;))</span><br></pre></td></tr></table></figure>

<h3 id="1-5-8-抽象类"><a href="#1-5-8-抽象类" class="headerlink" title="1.5.8. 抽象类"></a>1.5.8. 抽象类</h3><p>抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含<code>abstract</code>关键字并且可以包含访问修饰符。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Department &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    printName(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Department name: '</span> + <span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> printMeeting(): <span class="built_in">void</span> <span class="comment">// 必须在派生类中实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> AccountingDepartment <span class="keyword">extends</span> Department &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Accounting and Auditing'</span>) <span class="comment">// 在派生类的构造函数中必须调用 super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printMeeting(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'The Accounting Department meets each Monday at 10am.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    generateReports(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Generating accounting reports...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> department: Department <span class="comment">// 允许创建一个对抽象类型的引用</span></span><br><span class="line">department = <span class="keyword">new</span> Department() <span class="comment">// 错误: 不能创建一个抽象类的实例</span></span><br><span class="line">department = <span class="keyword">new</span> AccountingDepartment() <span class="comment">// 允许对一个抽象子类进行实例化和赋值</span></span><br><span class="line">department.printName()</span><br><span class="line">department.printMeeting()</span><br><span class="line">department.generateReports() <span class="comment">// 错误: 方法在声明的抽象类中不存在</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-9-用-typescript-实现多态"><a href="#1-5-9-用-typescript-实现多态" class="headerlink" title="1.5.9. 用 typescript 实现多态"></a>1.5.9. 用 typescript 实现多态</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ClockBase &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ticked...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> DigitalClock <span class="keyword">extends</span> ClockBase &#123;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'beep beep'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> AnalogClock <span class="keyword">extends</span> ClockBase &#123;</span><br><span class="line">    tick() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'tick tock'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> clocks: ClockBase[] = [<span class="keyword">new</span> DigitalClock(<span class="number">1</span>, <span class="number">1</span>), <span class="keyword">new</span> AnalogClock(<span class="number">1</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">clocks.forEach(<span class="function"><span class="params">c</span> =&gt;</span> c.tick())</span><br></pre></td></tr></table></figure>

<h2 id="1-6-函数"><a href="#1-6-函数" class="headerlink" title="1.6. 函数"></a>1.6. 函数</h2><h3 id="1-6-1-函数类型"><a href="#1-6-1-函数类型" class="headerlink" title="1.6.1. 函数类型"></a>1.6.1. 函数类型</h3><p>常规写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// named function</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// anonymous function</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整类型写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可写作</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-2-可选参数和默认参数"><a href="#1-6-2-可选参数和默认参数" class="headerlink" title="1.6.2. 可选参数和默认参数"></a>1.6.2. 可选参数和默认参数</h3><p>在所有必须参数后面的<code>带默认初始化值的参数都是可选的</code>，与可选参数一样，在调用函数的时候可以省略。 也就是说<code>可选参数与末尾的默认参数共享参数类型</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = 'Smith'</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享同样的类型<code>(firstName: string, lastName?: string) =&gt; string</code>。 默认参数的默认值消失了，只保留了它是一个可选参数的信息。</p>
<p>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。 如果带默认值的参数出现在必须参数前面，用户必须明确的传入<code>undefined</code>值来获得默认值。 例如，我们重写最后一个例子，让<code>firstName</code>是带默认值的参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName = 'Will', lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + lastName</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">'Bob'</span>) <span class="comment">// error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>, <span class="string">'Sr.'</span>) <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">'Bob'</span>, <span class="string">'Adams'</span>) <span class="comment">// okay and returns "Bob Adams"</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="literal">undefined</span>, <span class="string">'Adams'</span>) <span class="comment">// okay and returns "Will Adams"</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-3-剩余参数"><a href="#1-6-3-剩余参数" class="headerlink" title="1.6.3. 剩余参数"></a>1.6.3. 剩余参数</h3><p>在 TypeScript 里，你可以把所有参数收集到一个变量里：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + restOfName.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">'Joseph'</span>, <span class="string">'Samuel'</span>, <span class="string">'Lucas'</span>, <span class="string">'MacKinzie'</span>)</span><br></pre></td></tr></table></figure>

<p><code>剩余参数会被当做个数不限的可选参数</code>。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（<code>...</code>）后面给定的名字，你可以在函数体内使用这个数组。</p>
<p>这个省略号也会在带有剩余参数的<code>函数类型定义</code>上使用到：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">' '</span> + restOfName.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buildNameFun: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName</span><br></pre></td></tr></table></figure>

<h3 id="1-6-4-函数重载"><a href="#1-6-4-函数重载" class="headerlink" title="1.6.4. 函数重载"></a>1.6.4. 函数重载</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">'hearts'</span>, <span class="string">'spades'</span>, <span class="string">'clubs'</span>, <span class="string">'diamonds'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123; suit: <span class="built_in">string</span>; card: <span class="built_in">number</span> &#125;[]</span>): <span class="title">number</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123; <span class="title">suit</span>: <span class="title">string</span></span>; card: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length)</span><br><span class="line">        <span class="keyword">return</span> pickedCard</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>)</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [</span><br><span class="line">    &#123; suit: <span class="string">'diamonds'</span>, card: <span class="number">2</span> &#125;,</span><br><span class="line">    &#123; suit: <span class="string">'spades'</span>, card: <span class="number">10</span> &#125;,</span><br><span class="line">    &#123; suit: <span class="string">'hearts'</span>, card: <span class="number">4</span> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)]</span><br><span class="line">alert(<span class="string">'card: '</span> + pickedCard1.card + <span class="string">' of '</span> + pickedCard1.suit)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>)</span><br><span class="line">alert(<span class="string">'card: '</span> + pickedCard2.card + <span class="string">' of '</span> + pickedCard2.suit)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<code>function pickCard(x): any 并不是重载列表的一部分</code>，因此这里只有两个重载：一个是接收对象另一个接收数字。 所以其它参数调用 pickCard 会产生错误。</p>
</blockquote>
<h2 id="1-7-迭代器"><a href="#1-7-迭代器" class="headerlink" title="1.7. 迭代器"></a>1.7. 迭代器</h2><p>当一个对象实现了<code>Symbol.iterator</code>属性时，我们认为它是可迭代的。 一些内置的类型如<code>Array</code>，<code>Map</code>，<code>Set</code>，<code>String</code>，<code>Int32Array</code>，<code>Uint32Array</code>等都已经实现了各自的<code>Symbol.iterator</code>。对象上的<code>Symbol.iterator</code>函数负责返回供迭代的值。</p>
<h3 id="1-7-1-for-of-语句"><a href="#1-7-1-for-of-语句" class="headerlink" title="1.7.1. for..of 语句"></a>1.7.1. <code>for..of</code> 语句</h3><p><code>for..of</code>会遍历可迭代的对象，调用对象上的<code>Symbol.iterator</code>方法。 下面是在数组上使用<code>for..of</code>的简单例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someArray = [<span class="number">1</span>, <span class="string">'string'</span>, <span class="literal">false</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> entry of someArray) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(entry) <span class="comment">// 1, "string", false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-2-for-in-语句"><a href="#1-7-2-for-in-语句" class="headerlink" title="1.7.2. for..in 语句"></a>1.7.2. <code>for..in</code> 语句</h3><p><code>for..in</code>迭代的是对象的属性值<code>已经赋值</code>的<em>键</em>的列表。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    work() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'working...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    age = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span> = <span class="string">'zhang'</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error: Unauthorized update of employee!'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line"><span class="comment">//employee.fullName = 'Bob Smith'</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> employee) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age</span><br><span class="line">_fullName</span><br></pre></td></tr></table></figure>

<p>如果不给<code>fullName</code>或者<code>_fullName</code>赋值，则不会出现。</p>
<h3 id="1-7-3-for-of-vs-for-in-语句"><a href="#1-7-3-for-of-vs-for-in-语句" class="headerlink" title="1.7.3. for..of vs. for..in 语句"></a>1.7.3. <code>for..of</code> vs. <code>for..in</code> 语句</h3><p><code>for..of</code>和<code>for..in</code>均可迭代一个列表；但是用于迭代的值却不同，<code>for..in</code>迭代的是对象的<em>键</em>的列表，而<code>for..of</code>则迭代对象的键对应的值。</p>
<p>下面的例子展示了两者之间的区别：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// "0", "1", "2",</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i of list) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// "4", "5", "6"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个区别是<code>for..in</code>可以操作任何对象；它提供了查看对象属性的一种方法。 但是<code>for..of</code>关注于迭代对象的值。内置对象<code>Map</code>和<code>Set</code>已经实现了<code>Symbol.iterator</code>方法，让我们可以访问它们保存的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> Set([<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Hamster'</span>])</span><br><span class="line">pets[<span class="string">'species'</span>] = <span class="string">'mammals'</span></span><br><span class="line">;(&lt;<span class="built_in">any</span>&gt;pets).food = <span class="string">'rice'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">in</span> pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'--------------'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet of pets) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(pet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">species</span><br><span class="line">food</span><br><span class="line">--------------</span><br><span class="line">Cat</span><br><span class="line">Dog</span><br><span class="line">Hamster</span><br></pre></td></tr></table></figure>

<h2 id="1-8-泛型"><a href="#1-8-泛型" class="headerlink" title="1.8. 泛型"></a>1.8. 泛型</h2><h3 id="1-8-1-泛型定义"><a href="#1-8-1-泛型定义" class="headerlink" title="1.8.1. 泛型定义"></a>1.8.1. 泛型定义</h3><p>泛型程序设计 (Generic programming) 是指编写的代码可以被很多不同的类型的对象所重用。</p>
<h3 id="1-8-2-泛型类型"><a href="#1-8-2-泛型类型" class="headerlink" title="1.8.2. 泛型类型"></a>1.8.2. 泛型类型</h3><h4 id="1-8-2-1-常规声明方式"><a href="#1-8-2-1-常规声明方式" class="headerlink" title="1.8.2.1. 常规声明方式"></a>1.8.2.1. 常规声明方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity</span><br></pre></td></tr></table></figure>

<h4 id="1-8-2-2-泛型接口声明方式"><a href="#1-8-2-2-泛型接口声明方式" class="headerlink" title="1.8.2.2. 泛型接口声明方式"></a>1.8.2.2. 泛型接口声明方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>

<p>我们可能想把泛型参数当作整个接口的一个参数。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如：<code>Dictionary&lt;string&gt;</code>而不只是 <code>Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity</span><br></pre></td></tr></table></figure>

<h4 id="1-8-2-3-对象字面量声明方式"><a href="#1-8-2-3-对象字面量声明方式" class="headerlink" title="1.8.2.3. 对象字面量声明方式"></a>1.8.2.3. 对象字面量声明方式</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123; &lt;T&gt;(arg: T): T &#125; = identity</span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-泛型类"><a href="#1-8-3-泛型类" class="headerlink" title="1.8.3. 泛型类"></a>1.8.3. 泛型类</h3><p>泛型类看上去与泛型接口差不多。 泛型类使用（<code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span></span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-4-泛型约束"><a href="#1-8-4-泛型约束" class="headerlink" title="1.8.4. 泛型约束"></a>1.8.4. 泛型约束</h3><p>对泛型参数进行约束。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length) <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>) <span class="comment">// Error, number doesn't have a .length property</span></span><br></pre></td></tr></table></figure>

<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loggingIdentity(&#123; length: <span class="number">10</span>, value: <span class="number">3</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>构造函数约束：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>&lt;<span class="title">T</span>&gt;(<span class="params">c: &#123; <span class="keyword">new</span> (): T &#125;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-9-高级类型"><a href="#1-9-高级类型" class="headerlink" title="1.9. 高级类型"></a>1.9. 高级类型</h2><h3 id="1-9-1-交叉类型（Intersection-Types）"><a href="#1-9-1-交叉类型（Intersection-Types）" class="headerlink" title="1.9.1. 交叉类型（Intersection Types）"></a>1.9.1. 交叉类型（Intersection Types）</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，<code>Person &amp; Serializable &amp; Loggable</code>同时是<code>Person</code>和<code>Serializable</code>和<code>Loggable</code>。就是说这个类型的对象<code>同时拥有了这三种类型的成员</code>。</p>
<p>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在 JavaScript 里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        ;(&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(&lt;<span class="built_in">any</span>&gt;result).hasOwnProperty(id)) &#123;</span><br><span class="line">            ;(&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">    log(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'logging...'</span>) <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">'Jim'</span>), <span class="keyword">new</span> ConsoleLogger())</span><br><span class="line"><span class="keyword">var</span> n = jim.name</span><br><span class="line">jim.log()</span><br></pre></td></tr></table></figure>

<h3 id="1-9-2-联合类型（Union-Types）"><a href="#1-9-2-联合类型（Union-Types）" class="headerlink" title="1.9.2. 联合类型（Union Types）"></a>1.9.2. 联合类型（Union Types）</h3><p>联合类型表示一个值可以是几种类型之一。 我们用竖线（<code>|</code>）分隔每个类型，所以<code>number | string | boolean</code>表示一个值可以是<code>number</code>，<code>string</code>，或<code>boolean</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(padLeft(<span class="string">'Hello world'</span>, <span class="number">4</span>)) <span class="comment">// returns "    Hello world"</span></span><br><span class="line"><span class="built_in">console</span>.log(padLeft(<span class="string">'hi'</span>, <span class="string">'hi..'</span>)) <span class="comment">// returns "hi..hi"</span></span><br><span class="line"><span class="built_in">console</span>.log(padLeft(<span class="string">'hi'</span>, <span class="literal">true</span>)) <span class="comment">// error during compilation</span></span><br></pre></td></tr></table></figure>

<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly(): <span class="built_in">void</span></span><br><span class="line">    layEggs(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim(): <span class="built_in">void</span></span><br><span class="line">    layEggs(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        fly: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'flying...'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        layEggs: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'layingEggs...'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line">pet.layEggs() <span class="comment">// okay</span></span><br><span class="line">pet.swim() <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>

<p>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是<code>A | B</code>，我们能够<em>确定</em>的是它包含了<code>A</code>和<code>B</code>中共有的成员。 这个例子里，<code>Bird</code>具有一个<code>fly</code>成员。 我们不能确定一个<code>Bird | Fish</code>类型的变量是否有<code>fly</code>方法。 如果变量在运行时是<code>Fish</code>类型，那么调用<code>pet.fly()</code>就出错了。</p>
<h3 id="1-9-3-null-类型"><a href="#1-9-3-null-类型" class="headerlink" title="1.9.3. null 类型"></a>1.9.3. null 类型</h3><h4 id="1-9-3-1-null和undefined-赋值"><a href="#1-9-3-1-null和undefined-赋值" class="headerlink" title="1.9.3.1. null和undefined 赋值"></a>1.9.3.1. <code>null</code>和<code>undefined</code> 赋值</h4><p>TypeScript 具有两种特殊的类型，<code>null</code>和<code>undefined</code>，它们分别具有值 null 和 undefined. 默认情况下，类型检查器认为<code>null</code>与<code>undefined</code>可以赋值给任何类型。<code>null</code>与<code>undefined</code>是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。</p>
<p>但是<code>--strictNullChecks</code>标记可以解决此错误：当你声明一个变量时，它不会自动地包含<code>null</code>或<code>undefined</code>。 你可以使用联合类型明确的包含它们：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'foo'</span></span><br><span class="line">s = <span class="literal">null</span> <span class="comment">// 错误, 'null'不能赋值给'string'</span></span><br><span class="line"><span class="keyword">let</span> sn: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="string">'bar'</span></span><br><span class="line">sn = <span class="literal">null</span> <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">sn = <span class="literal">undefined</span> <span class="comment">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure>

<p>注意，按照 JavaScript 的语义，TypeScript 会把<code>null</code>和<code>undefined</code>区别对待。<code>string | null</code>，<code>string | undefined</code>和<code>string | undefined | null</code>是不同的类型。</p>
<h4 id="1-9-3-2-可选参数和可选属性"><a href="#1-9-3-2-可选参数和可选属性" class="headerlink" title="1.9.3.2. 可选参数和可选属性"></a>1.9.3.2. 可选参数和可选属性</h4><p>使用了<code>--strictNullChecks</code>，可选参数会被自动地加上<code>| undefined</code>:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + (y || <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">f(<span class="number">1</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">null</span>) <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure>

<p><img src="../../images/ts/WX20191123-060355@2x.png" alt=""></p>
<p>可选属性也会有同样的处理：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    a: <span class="built_in">number</span></span><br><span class="line">    b?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C()</span><br><span class="line">c.a = <span class="number">12</span></span><br><span class="line">c.a = <span class="literal">undefined</span> <span class="comment">// error, 'undefined' is not assignable to 'number'</span></span><br><span class="line">c.b = <span class="number">13</span></span><br><span class="line">c.b = <span class="literal">undefined</span> <span class="comment">// ok</span></span><br><span class="line">c.b = <span class="literal">null</span> <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure>

<h4 id="1-9-3-3-类型保护和类型断言"><a href="#1-9-3-3-类型保护和类型断言" class="headerlink" title="1.9.3.3. 类型保护和类型断言"></a>1.9.3.3. 类型保护和类型断言</h4><p>由于可以为 null 的类型是通过联合类型实现，那么你需要使用类型保护来去除<code>null</code>。 幸运地是这与在 JavaScript 里写的代码一致：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sn == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sn</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里很明显地去除了<code>null</code>，你也可以使用短路运算符：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sn || <span class="string">'default'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果编译器不能够去除<code>null</code>或<code>undefined</code>，你可以使用类型断言手动去除。 语法是添加<code>!</code>后缀：<code>identifier!</code>从<code>identifier</code>的类型里去除了<code>null</code>和<code>undefined</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet <span class="comment">// error, 'name' is possibly null</span></span><br><span class="line">    &#125;</span><br><span class="line">    name = name || <span class="string">'Bob'</span></span><br><span class="line">    <span class="keyword">return</span> postfix(<span class="string">'great'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    name = name || <span class="string">'Bob'</span></span><br><span class="line">    <span class="keyword">return</span> postfix(<span class="string">'great'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本例使用了嵌套函数，因为编译器无法去除嵌套函数的 null（除非是立即调用的函数表达式）。 因为它无法跟踪所有对嵌套函数的调用，尤其是你将内层函数做为外层函数的返回值。如果无法知道函数在哪里被调用，就无法知道调用时<code>name</code>的类型。</p>
<h3 id="1-9-4-类型别名"><a href="#1-9-4-类型别名" class="headerlink" title="1.9.4. 类型别名"></a>1.9.4. 类型别名</h3><h4 id="1-9-4-1-常规用法"><a href="#1-9-4-1-常规用法" class="headerlink" title="1.9.4.1. 常规用法"></a>1.9.4.1. 常规用法</h4><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>起别名不会新建一个类型 - 它创建了一个新<em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用类型别名来在属性里引用自己：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    value: T</span><br><span class="line">    left?: Tree&lt;T&gt;</span><br><span class="line">    right?: Tree&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tree: Tree&lt;<span class="built_in">number</span>&gt; = &#123;</span><br><span class="line">    value: <span class="number">10</span>,</span><br><span class="line">    left: &#123; value: <span class="number">5</span> &#125;,</span><br><span class="line">    right: &#123; value: <span class="number">11</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(tree)</span><br></pre></td></tr></table></figure>

<p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;</span><br><span class="line"><span class="keyword">var</span> s = people.name</span><br><span class="line"><span class="keyword">var</span> s = people.next.name</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.name</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.next.name</span><br></pre></td></tr></table></figure>

<p>然而，类型别名不能出现在声明右侧的任何地方。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h4 id="1-9-4-2-接口-vs-类型别名"><a href="#1-9-4-2-接口-vs-类型别名" class="headerlink" title="1.9.4.2. 接口 vs. 类型别名"></a>1.9.4.2. 接口 vs. 类型别名</h4><p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p>
<p>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。<br>其二，类型别名不能被<code>extends</code>和<code>implements</code>（自己也不能<code>extends</code>和<code>implements</code>其它类型）。 因为<a href="https://en.wikipedia.org/wiki/Open/closed_principle" target="_blank" rel="noopener">软件中的对象应该对于扩展是开放的，但是对于修改是封闭的</a>，你应该尽量去使用接口代替类型别名。</p>
<p>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p>
<h3 id="1-9-5-字符串字面量类型"><a href="#1-9-5-字符串字面量类型" class="headerlink" title="1.9.5. 字符串字面量类型"></a>1.9.5. 字符串字面量类型</h3><p>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span></span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">'ease-in'</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-out'</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-in-out'</span>) &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// error! should not pass null or undefined.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement()</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'ease-in'</span>)</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'uneasy'</span>) <span class="comment">// error: "uneasy" is not allowed here</span></span><br></pre></td></tr></table></figure>

<p>你只能从三种允许的字符中选择其一来做为参数传递，传入其它值则会产生错误。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Argument of <span class="keyword">type</span> <span class="string">'"uneasy"'</span> is not assignable to parameter of <span class="keyword">type</span> <span class="string">'"ease-in" | "ease-out" | "ease-in-out"'</span></span><br></pre></td></tr></table></figure>

<p>字符串字面量类型还可以用于区分函数重载：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: 'img'</span>): <span class="title">HTMLImageElement</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: 'input'</span>): <span class="title">HTMLInputElement</span></span></span></span><br><span class="line"><span class="function"><span class="function">// ... <span class="title">more</span> <span class="title">overloads</span> ...</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    // ... <span class="title">code</span> <span class="title">goes</span> <span class="title">here</span> ...</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-9-6-数字字面量类型"><a href="#1-9-6-数字字面量类型" class="headerlink" title="1.9.6. 数字字面量类型"></a>1.9.6. 数字字面量类型</h3><p>TypeScript 还具有数字字面量类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们很少直接这样使用，但它们可以用在缩小范围调试 bug 的时候：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="number">1</span> || x !== <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//         ~~~~~~~</span></span><br><span class="line">        <span class="comment">// Operator '!==' cannot be applied to types '1' and '2'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>换句话说，当<code>x</code>与<code>2</code>进行比较的时候，它的值必须为<code>1</code>，这就意味着上面的比较检查是非法的。</p>
<h3 id="1-9-7-枚举成员类型"><a href="#1-9-7-枚举成员类型" class="headerlink" title="1.9.7. 枚举成员类型"></a>1.9.7. 枚举成员类型</h3><p>枚举成员作为类型。</p>
<h3 id="1-9-8-可辨识联合（Discriminated-Unions）"><a href="#1-9-8-可辨识联合（Discriminated-Unions）" class="headerlink" title="1.9.8. 可辨识联合（Discriminated Unions）"></a>1.9.8. 可辨识联合（Discriminated Unions）</h3><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做<em>可辨识联合</em>的高级模式，它也称做<em>标签联合</em>或<em>代数数据类型</em>。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而 TypeScript 则基于已有的 JavaScript 模式。 它具有 3 个要素：</p>
<ol>
<li>具有普通的单例类型属性— _可辨识的特征_。</li>
<li>一个类型别名包含了那些类型的联合— _联合_。</li>
<li>此属性上的类型保护。</li>
</ol>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">'square'</span></span><br><span class="line">    size: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">'rectangle'</span></span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">'circle'</span></span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们声明了将要联合的接口。 每个接口都有<code>kind</code>属性但有不同的字符串字面量类型。<br><code>kind</code>属性称做<em>可辨识的特征</em>或<em>标签</em>。 其它的属性则特定于各个接口。 注意，目前各个接口间是没有联系的。 下面我们把它们联合到一起：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br></pre></td></tr></table></figure>

<p>现在我们使用可辨识联合:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">            <span class="keyword">return</span> s.size * s.size</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">            <span class="keyword">return</span> s.height * s.width</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-9-9-多态的this类型"><a href="#1-9-9-多态的this类型" class="headerlink" title="1.9.9. 多态的this类型"></a>1.9.9. 多态的<code>this</code>类型</h3><p>多态的<code>this</code>类型表示的是某个包含类或接口的<em>子类型<em>。 这被称做</em>F</em>-bounded 多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回<code>this</code>类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value += operand</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value *= operand</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other operations go here ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> BasicCalculator(<span class="number">2</span>)</span><br><span class="line">    .multiply(<span class="number">5</span>)</span><br><span class="line">    .add(<span class="number">1</span>)</span><br><span class="line">    .currentValue()</span><br></pre></td></tr></table></figure>

<p>由于这个类使用了<code>this</code>类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> sin(): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other operations go here ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">    .multiply(<span class="number">5</span>)</span><br><span class="line">    .sin()</span><br><span class="line">    .add(<span class="number">1</span>)</span><br><span class="line">    .currentValue()</span><br></pre></td></tr></table></figure>

<p>如果没有<code>this</code>类型，<code>ScientificCalculator</code>就不能够在继承<code>BasicCalculator</code>的同时还保持接口的连贯性。<code>multiply</code>将会返回<code>BasicCalculator</code>，它并没有<code>sin</code>方法。 然而，使用<code>this</code>类型，<code>multiply</code>会返回<code>this</code>，在这里就是<code>ScientificCalculator</code>。</p>
<h3 id="1-9-10-索引类型（Index-types）"><a href="#1-9-10-索引类型（Index-types）" class="headerlink" title="1.9.10. 索引类型（Index types）"></a>1.9.10. 索引类型（Index types）</h3><h4 id="1-9-10-1-索引类型查询操作符和索引访问操作符"><a href="#1-9-10-1-索引类型查询操作符和索引访问操作符" class="headerlink" title="1.9.10.1. 索引类型查询操作符和索引访问操作符"></a>1.9.10.1. 索引类型查询操作符和索引访问操作符</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]) <span class="comment">// ok, string[]</span></span><br><span class="line"><span class="keyword">let</span> values: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = pluck(person, [<span class="string">'name'</span>, <span class="string">'age'</span>]) <span class="comment">// ok,(string|number)[]</span></span><br></pre></td></tr></table></figure>

<p>编译器会检查<code>name</code>是否真的是<code>Person</code>的一个属性。 本例还引入了几个新的类型操作符。 首先是<code>keyof T</code>，<strong>索引类型查询操作符</strong>。 对于任何类型<code>T</code>，<code>keyof T</code>的结果为<code>T</code>上已知的公共属性名的联合。 例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps: keyof Person <span class="comment">// 'name' | 'age'</span></span><br></pre></td></tr></table></figure>

<p><code>keyof Person</code>是完全可以与<code>&#39;name&#39; | &#39;age&#39;</code>互相替换的。 不同的是如果你添加了其它的属性到<code>Person</code>，例如<code>address: string</code>，那么<code>keyof Person</code>会自动变为<code>&#39;name&#39; | &#39;age&#39; | &#39;address&#39;</code>。 你可以在像<code>pluck</code>函数这类上下文里使用<code>keyof</code>，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给<code>pluck</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pluck(person, [<span class="string">'age'</span>, <span class="string">'unknown'</span>]) <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure>

<p>第二个操作符是<code>T[K]</code>，<strong>索引访问操作符</strong>。 在这里，类型语法反映了表达式语法。 这意味着<code>person[&#39;name&#39;]</code>具有类型<code>Person[&#39;name&#39;]</code> — 在我们的例子里则为<code>string</code>类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用<code>T[K]</code>，这正是它的强大所在。 你只要确保类型变量<code>K extends keyof T</code>就可以了。 例如下面<code>getProperty</code>函数的例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o[name] <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getProperty</code>里的<code>o: T</code>和<code>name: K</code>，意味着<code>o[name]: T[K]</code>。 当你返回<code>T[K]</code>的结果，编译器会实例化键的真实类型，因此<code>getProperty</code>的返回值类型会随着你需要的属性改变。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = getProperty(person, <span class="string">'name'</span>)</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = getProperty(person, <span class="string">'age'</span>)</span><br><span class="line"><span class="keyword">let</span> unknown = getProperty(person, <span class="string">'unknown'</span>) <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：<code>keyof T</code>类似于字符串字面量，返回的是具体的属性值字面量类型，<code>T[K]</code>是取类型<code>T</code>具体属性<code>K</code>值的类型，例如<code>Person[age]</code>返回的是<code>number</code>类型。</p>
</blockquote>
<h4 id="1-9-10-2-索引类型和字符串索引签名"><a href="#1-9-10-2-索引类型和字符串索引签名" class="headerlink" title="1.9.10.2. 索引类型和字符串索引签名"></a>1.9.10.2. 索引类型和字符串索引签名</h4><p><code>keyof</code>和<code>T[K]</code>与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么<code>keyof T</code>会是<code>string</code>。 并且<code>T[string]</code>为索引签名的类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> value: Map&lt;<span class="built_in">number</span>&gt;[<span class="string">'foo'</span>] <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<h3 id="1-9-11-映射类型"><a href="#1-9-11-映射类型" class="headerlink" title="1.9.11. 映射类型"></a>1.9.11. 映射类型</h3><p>一个常见的任务是将一个已知的类型每个属性都变为可选的：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonPartial &#123;</span><br><span class="line">    name?: <span class="built_in">string</span></span><br><span class="line">    age?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者我们想要一个只读版本：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonReadonly &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span></span><br><span class="line">    readonly age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这在 JavaScript 里经常出现，TypeScript 提供了从旧类型中创建新类型的一种方式 —<strong>映射类型</strong>。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为<code>readonly</code>类型或可选的。 下面是一些例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意<code>T[P]</code>是值的类型，而不是值。</p>
</blockquote>
<p>像下面这样使用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure>

<p>下面来看看最简单的映射类型和它的组成部分：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">'option1'</span> | <span class="string">'option2'</span></span><br><span class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;</span><br></pre></td></tr></table></figure>

<p>它的语法与索引签名的语法类型，内部使用了<code>for .. in</code>。 具有三个部分：</p>
<ol>
<li>类型变量<code>K</code>，它会依次绑定到每个属性。</li>
<li>字符串字面量联合的<code>Keys</code>，它包含了要迭代的属性名的集合。</li>
<li>属性的结果类型。</li>
</ol>
<p>在这个简单的例子里，<code>Keys</code>是硬编码的的属性名列表并且属性类型永远是<code>boolean</code>，因此这个映射类型等同于：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">    option1: <span class="built_in">boolean</span></span><br><span class="line">    option2: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在真正的应用里，可能不同于上面的<code>Readonly</code>或<code>Partial</code>。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是<code>keyof</code>和索引访问类型要做的事情：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NullablePerson = &#123; [P <span class="keyword">in</span> keyof Person]: Person[P] | <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">type</span> PartialPerson = &#123; [P <span class="keyword">in</span> keyof Person]?: Person[P] &#125;</span><br></pre></td></tr></table></figure>

<p>但它更有用的地方是可以有一些通用版本。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Nullable&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: T[P] | <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-10-模块"><a href="#1-10-模块" class="headerlink" title="1.10. 模块"></a>1.10. 模块</h2><h3 id="1-10-1-内部模块和外部模块"><a href="#1-10-1-内部模块和外部模块" class="headerlink" title="1.10.1. 内部模块和外部模块"></a>1.10.1. 内部模块和外部模块</h3><p>“内部模块”现在称做“命名空间”。 “外部模块”现在则简称为“模块”，这是为了与 ECMAScript 2015 里的术语保持一致，(也就是说 <code>module X {}</code> 相当于现在推荐的写法 <code>namespace X {}</code>)。</p>
<h3 id="1-10-2-外部模块"><a href="#1-10-2-外部模块" class="headerlink" title="1.10.2. 外部模块"></a>1.10.2. 外部模块</h3><p>文件模块也被称为外部模块。如果在你的 TypeScript 文件的根级别位置<code>含有 import 或者 export</code>，它会在这个文件中<code>创建一个本地的作用域</code>。</p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里；这意味着定义在一个模块里的变量，函数，类等等在模块外部是不可见的，除非你明确地使用 export 形式之一导出它们。 相反，如果想使用其它模块导出的变量，函数，类，接口等的时候，你必须要导入它们，可以使用 import 形式之一。</p>
<p>模块使用模块加载器去导入其它的模块。 在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。 大家最熟知的 JavaScript 模块加载器是服务于 Node.js 的 CommonJS 和服务于 Web 应用的 Require.js。</p>
<p>TypeScript 与 ECMAScript 2015 一样，<code>任何包含顶级 import 或者 export 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的</code>（因此对模块也是可见的）。</p>
<p><code>CommonJs</code> 不被浏览器端支持， 因为浏览器没有 <code>module, exports, require, global</code> 四个环境变量。</p>
<p>UMD 模块是指那些既可以作为模块使用（通过导入）又可以作为全局（在没有模块加载器的环境里）使用的模块。</p>
<h3 id="1-10-3-导出"><a href="#1-10-3-导出" class="headerlink" title="1.10.3. 导出"></a>1.10.3. 导出</h3><h4 id="1-10-3-1-导出声明"><a href="#1-10-3-1-导出声明" class="headerlink" title="1.10.3.1. 导出声明"></a>1.10.3.1. 导出声明</h4><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加<code>export</code>关键字来导出。</p>
<h5 id="1-10-3-1-1-Validation-ts"><a href="#1-10-3-1-1-Validation-ts" class="headerlink" title="1.10.3.1.1. Validation.ts"></a>1.10.3.1.1. Validation.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-10-3-1-2-ZipCodeValidator-ts"><a href="#1-10-3-1-2-ZipCodeValidator-ts" class="headerlink" title="1.10.3.1.2. ZipCodeValidator.ts"></a>1.10.3.1.2. ZipCodeValidator.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-3-2-导出语句"><a href="#1-10-3-2-导出语句" class="headerlink" title="1.10.3.2. 导出语句"></a>1.10.3.2. 导出语句</h4><p>导出语句很便利，因为我们可能需要对导出的部分重命名，所以上面的例子可以这样改写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> mainValidator &#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-3-3-重新导出"><a href="#1-10-3-3-重新导出" class="headerlink" title="1.10.3.3. 重新导出"></a>1.10.3.3. 重新导出</h4><p>我们经常会去扩展其它模块，并且只导出那个模块的部分内容。 重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<h5 id="1-10-3-3-1-ParseIntBasedZipCodeValidator-ts"><a href="#1-10-3-3-1-ParseIntBasedZipCodeValidator-ts" class="headerlink" title="1.10.3.3.1. ParseIntBasedZipCodeValidator.ts"></a>1.10.3.3.1. ParseIntBasedZipCodeValidator.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> ParseIntBasedZipCodeValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; <span class="built_in">parseInt</span>(s).toString() === s</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出原先的验证器但做了重命名</span></span><br><span class="line"><span class="keyword">export</span> &#123; ZipCodeValidator <span class="keyword">as</span> RegExpBasedZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br></pre></td></tr></table></figure>

<p>或者一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：<code>export * from &quot;module&quot;</code>。</p>
<h5 id="1-10-3-3-2-AllValidators-ts"><a href="#1-10-3-3-2-AllValidators-ts" class="headerlink" title="1.10.3.3.2. AllValidators.ts"></a>1.10.3.3.2. AllValidators.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./StringValidator'</span> <span class="comment">// exports interface StringValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./LettersOnlyValidator'</span> <span class="comment">// exports class LettersOnlyValidator</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span> <span class="comment">// exports class ZipCodeValidator</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-4-导入"><a href="#1-10-4-导入" class="headerlink" title="1.10.4. 导入"></a>1.10.4. 导入</h3><p>模块的导入操作与导出一样简单。 可以使用以下<code>import</code>形式之一来导入其它模块中的导出内容。</p>
<h4 id="1-10-4-1-导入一个模块中的某个导出内容"><a href="#1-10-4-1-导入一个模块中的某个导出内容" class="headerlink" title="1.10.4.1. 导入一个模块中的某个导出内容"></a>1.10.4.1. 导入一个模块中的某个导出内容</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZipCodeValidator()</span><br></pre></td></tr></table></figure>

<p>可以对导入内容重命名</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ZipCodeValidator <span class="keyword">as</span> ZCV &#125; <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> ZCV()</span><br></pre></td></tr></table></figure>

<h4 id="1-10-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分"><a href="#1-10-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分" class="headerlink" title="1.10.4.2. 将整个模块导入到一个变量，并通过它来访问模块的导出部分"></a>1.10.4.2. 将整个模块导入到一个变量，并通过它来访问模块的导出部分</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> validator <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator.ZipCodeValidator()</span><br></pre></td></tr></table></figure>

<h4 id="1-10-4-3-具有副作用的导入模块"><a href="#1-10-4-3-具有副作用的导入模块" class="headerlink" title="1.10.4.3. 具有副作用的导入模块"></a>1.10.4.3. 具有副作用的导入模块</h4><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。 这些模块可能没有任何的导出或用户根本就不关注它的导出。 使用下面的方法来导入这类模块：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./my-module.js'</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-5-默认导出"><a href="#1-10-5-默认导出" class="headerlink" title="1.10.5. 默认导出"></a>1.10.5. 默认导出</h3><p>类和函数声明可以直接被标记为默认导出。 标记为默认导出的类和函数的名字是可以省略的。</p>
<h4 id="1-10-5-1-导出类"><a href="#1-10-5-1-导出类" class="headerlink" title="1.10.5.1. 导出类"></a>1.10.5.1. 导出类</h4><h5 id="1-10-5-1-1-ZipCodeValidator-ts"><a href="#1-10-5-1-1-ZipCodeValidator-ts" class="headerlink" title="1.10.5.1.1. ZipCodeValidator.ts"></a>1.10.5.1.1. ZipCodeValidator.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> ZipCodeValidator &#123;</span><br><span class="line">    <span class="keyword">static</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; ZipCodeValidator.numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-10-5-1-2-Test1-ts"><a href="#1-10-5-1-2-Test1-ts" class="headerlink" title="1.10.5.1.2. Test1.ts"></a>1.10.5.1.2. Test1.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> validator <span class="keyword">from</span> <span class="string">'./ZipCodeValidator'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myValidator = <span class="keyword">new</span> validator()</span><br></pre></td></tr></table></figure>

<h4 id="1-10-5-2-导出函数"><a href="#1-10-5-2-导出函数" class="headerlink" title="1.10.5.2. 导出函数"></a>1.10.5.2. 导出函数</h4><h4 id="1-10-5-3-StaticZipCodeValidator-ts"><a href="#1-10-5-3-StaticZipCodeValidator-ts" class="headerlink" title="1.10.5.3. StaticZipCodeValidator.ts"></a>1.10.5.3. StaticZipCodeValidator.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">s: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-10-5-4-Test2-ts"><a href="#1-10-5-4-Test2-ts" class="headerlink" title="1.10.5.4. Test2.ts"></a>1.10.5.4. Test2.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> validate <span class="keyword">from</span> <span class="string">'./StaticZipCodeValidator'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">'Hello'</span>, <span class="string">'98052'</span>, <span class="string">'101'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use function validate</span></span><br><span class="line">strings.forEach(<span class="function"><span class="params">s</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;s&#125;</span>" <span class="subst">$&#123;validate(s) ? <span class="string">' matches'</span> : <span class="string">' does not match'</span>&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="1-10-5-5-导出一个值"><a href="#1-10-5-5-导出一个值" class="headerlink" title="1.10.5.5. 导出一个值"></a>1.10.5.5. 导出一个值</h4><h5 id="1-10-5-5-1-OneTwoThree-ts"><a href="#1-10-5-5-1-OneTwoThree-ts" class="headerlink" title="1.10.5.5.1. OneTwoThree.ts"></a>1.10.5.5.1. OneTwoThree.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">'123'</span></span><br></pre></td></tr></table></figure>

<h5 id="1-10-5-5-2-Log-ts"><a href="#1-10-5-5-2-Log-ts" class="headerlink" title="1.10.5.5.2. Log.ts"></a>1.10.5.5.2. Log.ts</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> num <span class="keyword">from</span> <span class="string">'./OneTwoThree'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">// "123"</span></span><br></pre></td></tr></table></figure>

<h3 id="1-10-6-模块解析"><a href="#1-10-6-模块解析" class="headerlink" title="1.10.6. 模块解析"></a>1.10.6. 模块解析</h3><p>模块解析是指编译器在查找导入模块内容时所遵循的流程。</p>
<h4 id="1-10-6-1-相对-vs-非相对模块导入"><a href="#1-10-6-1-相对-vs-非相对模块导入" class="headerlink" title="1.10.6.1. 相对 vs. 非相对模块导入"></a>1.10.6.1. 相对 vs. 非相对模块导入</h4><p>根据模块引用是相对的还是非相对的，模块导入会以不同的方式解析。</p>
<p><em>相对导入</em>是以<code>/</code>，<code>./</code>或<code>../</code>开头的。 下面是一些例子：</p>
<ul>
<li><code>import Entry from &quot;./components/Entry&quot;;</code></li>
<li><code>import { DefaultHeaders } from &quot;../constants/http&quot;;</code></li>
<li><code>import &quot;/mod&quot;;</code></li>
</ul>
<p>所有其它形式的导入被当作<em>非相对</em>的。 下面是一些例子：</p>
<ul>
<li><code>import * as $ from &quot;jQuery&quot;;</code></li>
<li><code>import { Component } from &quot;@angular/core&quot;;</code></li>
</ul>
<p>相对导入在解析时是相对于导入它的文件，并且<em>不能</em>解析为一个外部模块声明。 你应该为你自己写的模块使用相对导入，这样能确保它们在运行时的相对位置。</p>
<p>非相对模块的导入可以相对于<code>baseUrl</code>或通过下文会讲到的路径映射来进行解析。 它们还可以被解析成外部模块声明。 使用非相对路径来导入你的外部依赖。</p>
<h3 id="1-10-7-模块解析策略"><a href="#1-10-7-模块解析策略" class="headerlink" title="1.10.7. 模块解析策略"></a>1.10.7. 模块解析策略</h3><p>共有两种可用的模块解析策略：Node 和 Classic。 你可以使用<code>--moduleResolution</code>标记来指定使用哪种模块解析策略。若未指定，那么在使用了<code>--module AMD | System | ES2015</code>时的默认值为 Classic，其它情况时则为 Node。</p>
<h4 id="1-10-7-1-Classic"><a href="#1-10-7-1-Classic" class="headerlink" title="1.10.7.1. Classic"></a>1.10.7.1. Classic</h4><p>这种策略在以前是 TypeScript 默认的解析策略。 现在，它存在的理由主要是为了向后兼容。</p>
<h5 id="1-10-7-1-1-相对模块导入"><a href="#1-10-7-1-1-相对模块导入" class="headerlink" title="1.10.7.1.1. 相对模块导入"></a>1.10.7.1.1. 相对模块导入</h5><p>相对导入的模块是相对于导入它的文件进行解析的。 因此<code>/root/src/folder/A.ts</code>文件里的<code>import { b } from &quot;./moduleB</code>会使用下面的查找流程：</p>
<ol>
<li><code>/root/src/folder/moduleB.ts</code></li>
<li><code>/root/src/folder/moduleB.d.ts</code></li>
</ol>
<h5 id="1-10-7-1-2-非相对模块导入"><a href="#1-10-7-1-2-非相对模块导入" class="headerlink" title="1.10.7.1.2. 非相对模块导入"></a>1.10.7.1.2. 非相对模块导入</h5><p>对于非相对模块的导入，编译器则会从包含导入文件的目录开始依次向上级目录遍历，尝试定位匹配的声明文件。</p>
<p>比如：有一个对<code>moduleB</code>的非相对导入<code>import { b } from &quot;moduleB</code>，它是在<code>/root/src/folder/A.ts</code>文件里，会以如下的方式来定位<code>moduleB</code>：</p>
<ol>
<li><code>/root/src/folder/moduleB.ts</code></li>
<li><code>/root/src/folder/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/moduleB.ts</code></li>
<li><code>/root/moduleB.d.ts</code></li>
<li><code>/moduleB.ts</code></li>
<li><code>/moduleB.d.ts</code></li>
</ol>
<h4 id="1-10-7-2-Node"><a href="#1-10-7-2-Node" class="headerlink" title="1.10.7.2. Node"></a>1.10.7.2. Node</h4><p>为了理解 TypeScript 编译依照的解析步骤，先弄明白 Node.js 模块是非常重要的。 通常，在 Node.js 里导入是通过<code>require</code>函数调用进行的。 Node.js 会根据<code>require</code>的是相对路径还是非相对路径做出不同的行为。</p>
<h5 id="1-10-7-2-1-相对路径"><a href="#1-10-7-2-1-相对路径" class="headerlink" title="1.10.7.2.1. 相对路径"></a>1.10.7.2.1. 相对路径</h5><p>相对路径很简单。 例如，假设有一个文件路径为<code>/root/src/moduleA.js</code>，包含了一个导入<code>var x = require(&quot;./moduleB&quot;);</code> Node.js 以下面的顺序解析这个导入：</p>
<ol>
<li>检查<code>/root/src/moduleB.js</code>文件是否存在。</li>
<li>检查<code>/root/src/moduleB</code>目录是否包含一个<code>package.json</code>文件，且<code>package.json</code>文件指定了一个<code>main</code>模块。<br>在我们的例子里，如果 Node.js 发现文件<br><code>/root/src/moduleB/package.json</code>包含了<code>{ &quot;main&quot;: &quot;lib/mainModule.js&quot; }</code>，那么 Node.js 会引用<code>/root/src/moduleB/lib/mainModule.js</code>。</li>
<li>检查<code>/root/src/moduleB</code>目录是否包含一个<code>index.js</code>文件。 这个文件会被隐式地当作那个文件夹下的”main”模块。</li>
</ol>
<p>但是，<code>非相对模块名</code>的解析是个完全不同的过程。 Node 会在一个特殊的文件夹<code>node_modules</code>里查找你的模块。<code>node_modules</code>可能与当前文件在同一级目录下，或者在上层目录里。 Node 会向上级目录遍历，查找每个<code>node_modules</code>直到它找到要加载的模块。</p>
<h5 id="1-10-7-2-2-非相对路径"><a href="#1-10-7-2-2-非相对路径" class="headerlink" title="1.10.7.2.2. 非相对路径"></a>1.10.7.2.2. 非相对路径</h5><p>还是用上面例子，但假设<code>/root/src/moduleA.js</code>里使用的是非相对路径导入<code>var x = require(&quot;moduleB&quot;);</code>。<br>Node 则会以下面的顺序去解析<code>moduleB</code>，直到有一个匹配上。</p>
<ol>
<li><code>/root/src/node_modules/moduleB.js</code></li>
<li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>main</code>属性)</li>
<li><code>/root/src/node_modules/moduleB/index.js</code></li>
<li><code>/root/node_modules/moduleB.js</code></li>
<li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>main</code>属性)</li>
<li><code>/root/node_modules/moduleB/index.js</code></li>
<li><code>/node_modules/moduleB.js</code></li>
<li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>main</code>属性)</li>
<li><code>/node_modules/moduleB/index.js</code></li>
</ol>
<h4 id="1-10-7-3-TypeScript"><a href="#1-10-7-3-TypeScript" class="headerlink" title="1.10.7.3. TypeScript"></a>1.10.7.3. TypeScript</h4><p>TypeScript 是模仿 Node.js 运行时的解析策略来在编译阶段定位模块定义文件。 因此，TypeScript 在 Node 解析逻辑基础上增加了 TypeScript 源文件的扩展名（<code>.ts</code>，<code>.tsx</code>和<code>.d.ts</code>）。 同时，TypeScript 在<code>package.json</code>里使用字段<code>types</code>来表示类似<code>main</code>的意义 - 编译器会使用它来找到要使用的”main”定义文件。</p>
<h5 id="1-10-7-3-1-相对导入"><a href="#1-10-7-3-1-相对导入" class="headerlink" title="1.10.7.3.1. 相对导入"></a>1.10.7.3.1. 相对导入</h5><p>比如，有一个导入语句<code>import { b } from &quot;./moduleB</code>在<code>/root/src/moduleA.ts</code>里，会以下面的流程来定位<code>./moduleB</code>：</p>
<ol>
<li><code>/root/src/moduleB.ts</code></li>
<li><code>/root/src/moduleB.tsx</code></li>
<li><code>/root/src/moduleB.d.ts</code></li>
<li><code>/root/src/moduleB/package.json</code> (如果指定了<code>types</code>属性)</li>
<li><code>/root/src/moduleB/index.ts</code></li>
<li><code>/root/src/moduleB/index.tsx</code></li>
<li><code>/root/src/moduleB/index.d.ts</code></li>
</ol>
<p>回想一下 Node.js 先查找<code>moduleB.js</code>文件，然后是合适的<code>package.json</code>，再之后是<code>index.js</code>。</p>
<h5 id="1-10-7-3-2-非相对导入"><a href="#1-10-7-3-2-非相对导入" class="headerlink" title="1.10.7.3.2. 非相对导入"></a>1.10.7.3.2. 非相对导入</h5><p>类似地，非相对的导入会遵循 Node.js 的解析逻辑，首先查找文件，然后是合适的文件夹。 因此<br><code>/root/src/moduleA.ts</code>文件里的<code>import { b } from &quot;moduleB</code>会以下面的查找顺序解析：</p>
<ol>
<li><code>/root/src/node_modules/moduleB.ts</code></li>
<li><code>/root/src/node_modules/moduleB.tsx</code></li>
<li><code>/root/src/node_modules/moduleB.d.ts</code></li>
<li><code>/root/src/node_modules/moduleB/package.json</code> (如果指定了<code>types</code>属性)</li>
<li><code>/root/src/node_modules/moduleB/index.ts</code></li>
<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>
<li><code>/root/src/node_modules/moduleB/index.d.ts</code></li>
<li><code>/root/node_modules/moduleB.ts</code></li>
<li><code>/root/node_modules/moduleB.tsx</code></li>
<li><code>/root/node_modules/moduleB.d.ts</code></li>
<li><code>/root/node_modules/moduleB/package.json</code> (如果指定了<code>types</code>属性)</li>
<li><code>/root/node_modules/moduleB/index.ts</code></li>
<li><code>/root/node_modules/moduleB/index.tsx</code></li>
<li><code>/root/node_modules/moduleB/index.d.ts</code></li>
<li><code>/node_modules/moduleB.ts</code></li>
<li><code>/node_modules/moduleB.tsx</code></li>
<li><code>/node_modules/moduleB.d.ts</code></li>
<li><code>/node_modules/moduleB/package.json</code> (如果指定了<code>types</code>属性)</li>
<li><code>/node_modules/moduleB/index.ts</code></li>
<li><code>/node_modules/moduleB/index.tsx</code></li>
<li><code>/node_modules/moduleB/index.d.ts</code></li>
</ol>
<p>不要被这里步骤的数量吓到 - TypeScript 只是在步骤（8）和（15）向上跳了两次目录。 这并不比 Node.js 里的流程复杂。<br>注意 Node.js 在步骤（4）和（7）会向上跳一级目录。</p>
<h2 id="1-11-TSX"><a href="#1-11-TSX" class="headerlink" title="1.11. TSX"></a>1.11. TSX</h2><p>JSX 是一种嵌入式的类似 XML 的语法。 它可以被转换成合法的 JavaScript，尽管转换的语义是依据不同的实现而定的。 JSX 因 React 框架而流行，但也存在其它的实现。 TypeScript 支持内嵌，类型检查以及将 JSX 直接编译为 JavaScript。</p>
<h3 id="1-11-1-基本用法"><a href="#1-11-1-基本用法" class="headerlink" title="1.11.1. 基本用法"></a>1.11.1. 基本用法</h3><p>想要使用 JSX 必须做两件事：</p>
<ol>
<li>给文件一个<code>.tsx</code>扩展名</li>
<li>启用<code>jsx</code>选项</li>
</ol>
<p>TypeScript 具有三种 JSX 模式：<code>preserve</code>，<code>react</code>和<code>react-native</code>。这些模式只在代码生成阶段起作用，类型检查并不受影响。</p>
<ul>
<li>在<code>preserve</code>模式下生成代码中会保留 JSX 以供后续的转换操作使用（比如：<a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>）。另外，输出文件会带有<code>.jsx</code>扩展名。</li>
<li><code>react</code>模式会生成<code>React.createElement</code>，在使用前不需要再进行转换操作了，输出文件的扩展名为<code>.js</code>。</li>
<li><code>react-native</code>相当于<code>preserve</code>，它也保留了所有的 JSX，但是输出文件的扩展名是<code>.js</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>输入</th>
<th>输出</th>
<th>输出文件扩展名</th>
</tr>
</thead>
<tbody><tr>
<td><code>preserve</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>.jsx</code></td>
</tr>
<tr>
<td><code>react</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>React.createElement(&quot;div&quot;)</code></td>
<td><code>.js</code></td>
</tr>
<tr>
<td><code>react-native</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>&lt;div /&gt;</code></td>
<td><code>.js</code></td>
</tr>
</tbody></table>
<p>你可以通过在命令行里使用<code>--jsx</code>标记或 tsconfig.json 里的选项来指定模式。</p>
<blockquote>
<p><em>注意：<code>React</code>标识符是写死的硬编码，所以你必须保证 React（大写的 R）是可用的。</em></p>
</blockquote>
<h3 id="1-11-2-as操作符"><a href="#1-11-2-as操作符" class="headerlink" title="1.11.2. as操作符"></a>1.11.2. <code>as</code>操作符</h3><p>回想一下怎么写类型断言：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &lt;foo&gt;bar</span><br></pre></td></tr></table></figure>

<p>这里断言<code>bar</code>变量是<code>foo</code>类型的。因为 TypeScript 也使用尖括号来表示类型断言，在结合 JSX 的语法后将带来解析上的困难。因此，TypeScript 在<code>.tsx</code>文件里禁用了使用尖括号的类型断言。</p>
<p>由于不能够在<code>.tsx</code>文件里使用上述语法，因此我们应该使用另一个类型断言操作符：<code>as</code>。上面的例子可以很容易地使用<code>as</code>操作符改写：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = bar <span class="keyword">as</span> foo</span><br></pre></td></tr></table></figure>

<p><code>as</code>操作符在<code>.ts</code>和<code>.tsx</code>里都可用，并且与尖括号类型断言行为是等价的。</p>
<h3 id="1-11-3-类型检查"><a href="#1-11-3-类型检查" class="headerlink" title="1.11.3. 类型检查"></a>1.11.3. 类型检查</h3><p>为了理解 JSX 的类型检查，你必须首先理解固有元素与基于值的元素之间的区别。假设有这样一个 JSX 表达式<code>&lt;expr /&gt;</code>，<code>expr</code>可能引用环境自带的某些东西（比如，在 DOM 环境里的<code>div</code>或<code>span</code>）或者是你自定义的组件。这是非常重要的，原因有如下两点：</p>
<ol>
<li>对于 React，固有元素会生成字符串（<code>React.createElement(&quot;div&quot;)</code>），然而由你自定义的组件却不会生成（<code>React.createElement(MyComponent)</code>）。</li>
<li>传入 JSX 元素里的属性类型的查找方式不同。固有元素属性<em>本身</em>就支持，然而自定义的组件会自己去指定它们具有哪个属性。</li>
</ol>
<p>TypeScript 使用<a href="http://facebook.github.io/react/docs/jsx-in-depth.html#html-tags-vs.-react-components" target="_blank" rel="noopener">与 React 相同的规范</a>来区别它们。</p>
<p>固有元素总是以一个小写字母开头，基于值的元素总是以一个大写字母开头。</p>
<h4 id="1-11-3-1-固有元素"><a href="#1-11-3-1-固有元素" class="headerlink" title="1.11.3.1. 固有元素"></a>1.11.3.1. 固有元素</h4><p>固有元素使用特殊的接口<code>JSX.IntrinsicElements</code>来查找。<br>默认地，如果这个接口没有指定，会全部通过，不对固有元素进行类型检查。<br>然而，如果这个接口存在，那么固有元素的名字需要在<code>JSX.IntrinsicElements</code>接口的属性里查找。<br>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">    <span class="keyword">interface</span> IntrinsicElements &#123;</span><br><span class="line">        foo: <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">;&lt;foo /&gt; <span class="comment">// 正确</span></span><br><span class="line">;&lt;bar /&gt; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<p>在上例中，<code>&lt;foo /&gt;</code>没有问题，但是<code>&lt;bar /&gt;</code>会报错，因为它没在<code>JSX.IntrinsicElements</code>里指定。</p>
<p>注意：你也可以在<code>JSX.IntrinsicElements</code>上指定一个用来捕获所有字符串索引：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">namespace</span> JSX &#123;</span><br><span class="line">    <span class="keyword">interface</span> IntrinsicElements &#123;</span><br><span class="line">        [elemName: <span class="built_in">string</span>]: <span class="built_in">any</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-11-3-2-基于值的元素"><a href="#1-11-3-2-基于值的元素" class="headerlink" title="1.11.3.2. 基于值的元素"></a>1.11.3.2. 基于值的元素</h4><p>基于值的元素会简单的在它所在的作用域里按标识符查找。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">'./myComponent'</span></span><br><span class="line">;&lt;MyComponent /&gt; <span class="comment">// 正确</span></span><br><span class="line">;&lt;SomeOtherComponent /&gt; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="1-12-命名空间"><a href="#1-12-命名空间" class="headerlink" title="1.12. 命名空间"></a>1.12. 命名空间</h2><p>“内部模块”现在叫做“命名空间”。 另外，任何使用<code>module</code>关键字来声明一个内部模块的地方都应该使用<code>namespace</code>关键字来替换。 这就避免了让新的使用者被相似的名称所迷惑。</p>
<h3 id="1-12-1-单文件命名空间"><a href="#1-12-1-单文件命名空间" class="headerlink" title="1.12.1. 单文件命名空间"></a>1.12.1. 单文件命名空间</h3><h4 id="1-12-1-1-TestAll-ts"><a href="#1-12-1-1-TestAll-ts" class="headerlink" title="1.12.1.1. TestAll.ts"></a>1.12.1.1. TestAll.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span></span><br><span class="line">    <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.test(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">'Hello'</span>, <span class="string">'98052'</span>, <span class="string">'101'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;</span><br><span class="line">validators[<span class="string">'ZIP code'</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator()</span><br><span class="line">validators[<span class="string">'Letters only'</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                validators[name].isAcceptable(s) ? <span class="string">'matches'</span> : <span class="string">'does not match'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-12-2-多文件中的命名空间"><a href="#1-12-2-多文件中的命名空间" class="headerlink" title="1.12.2. 多文件中的命名空间"></a>1.12.2. 多文件中的命名空间</h3><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。现在，我们把<code>Validation</code>命名空间分割成多个文件。 尽管是不同的文件，它们仍是同一个命名空间，并且在使用的时候就如同它们在一个文件中定义的一样。因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。我们的测试代码保持不变。</p>
<h4 id="1-12-2-1-Validation-ts"><a href="#1-12-2-1-Validation-ts" class="headerlink" title="1.12.2.1. Validation.ts"></a>1.12.2.1. Validation.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-2-2-LettersOnlyValidator-ts"><a href="#1-12-2-2-LettersOnlyValidator-ts" class="headerlink" title="1.12.2.2. LettersOnlyValidator.ts"></a>1.12.2.2. LettersOnlyValidator.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="keyword">const</span> lettersRegexp = <span class="regexp">/^[A-Za-z]+$/</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lettersRegexp.test(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-2-3-ZipCodeValidator-ts"><a href="#1-12-2-3-ZipCodeValidator-ts" class="headerlink" title="1.12.2.3. ZipCodeValidator.ts"></a>1.12.2.3. ZipCodeValidator.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">    <span class="keyword">const</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">        isAcceptable(s: <span class="built_in">string</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-12-2-4-Test-ts"><a href="#1-12-2-4-Test-ts" class="headerlink" title="1.12.2.4. Test.ts"></a>1.12.2.4. Test.ts</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="Validation.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="LettersOnlyValidator.ts" /&gt;</span></span><br><span class="line"><span class="comment">/// &lt;reference path="ZipCodeValidator.ts" /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Some samples to try</span></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">'Hello'</span>, <span class="string">'98052'</span>, <span class="string">'101'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validators to use</span></span><br><span class="line"><span class="keyword">let</span> validators: &#123; [s: <span class="built_in">string</span>]: Validation.StringValidator &#125; = &#123;&#125;</span><br><span class="line">validators[<span class="string">'ZIP code'</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator()</span><br><span class="line">validators[<span class="string">'Letters only'</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Show whether each string passed each validator</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s of strings) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;s&#125;</span>" - <span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">                validators[name].isAcceptable(s) ? <span class="string">'matches'</span> : <span class="string">'does not match'</span></span></span></span><br><span class="line"><span class="string"><span class="subst">            &#125;</span> <span class="subst">$&#123;name&#125;</span>`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当涉及到多文件时，我们必须确保所有编译后的代码都被加载了。 我们有两种方式。</p>
<p>第一种方式，把所有的输入文件编译为一个输出文件，需要使用<code>--outFile</code>标记：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sampleAll.js TestAll.ts</span><br><span class="line">node ./sampleAll.js</span><br></pre></td></tr></table></figure>

<p>编译器会根据源码里的引用标签自动地对输出进行排序。你也可以单独地指定每个文件。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --outFile sample.js Validation.ts LettersOnlyValidator.ts ZipCodeValidator.ts Test.ts</span><br></pre></td></tr></table></figure>

<h3 id="1-12-3-别名"><a href="#1-12-3-别名" class="headerlink" title="1.12.3. 别名"></a>1.12.3. 别名</h3><p>另一种简化命名空间操作的方法是使用<code>import q = x.y.z</code>给常用的对象起一个短的名字。 不要与用来加载模块的<br><code>import x = require(&#39;name&#39;)</code>语法弄混了，这里的语法是为指定的符号创建一个别名。 你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Triangle &#123;&#125;</span><br><span class="line">        <span class="keyword">export</span> <span class="keyword">class</span> Square &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> polygons = Shapes.Polygons</span><br><span class="line"><span class="keyword">let</span> sq = <span class="keyword">new</span> polygons.Square() <span class="comment">// Same as "new Shapes.Polygons.Square()"</span></span><br></pre></td></tr></table></figure>

<h2 id="1-13-装饰器"><a href="#1-13-装饰器" class="headerlink" title="1.13. 装饰器"></a>1.13. 装饰器</h2><p>随着 TypeScript 和 ES6 里引入了类，在一些场景下我们需要额外的特性来支持标注或修改类及其成员。 装饰器（Decorators）为我们在类的声明及成员上通过元编程语法添加标注提供了一种方式。</p>
<h3 id="1-13-1-编译器配置"><a href="#1-13-1-编译器配置" class="headerlink" title="1.13.1. 编译器配置"></a>1.13.1. 编译器配置</h3><p>若要启用实验性的装饰器特性，你必须在命令行或<code>tsconfig.json</code>里启用<code>experimentalDecorators</code>编译器选项：</p>
<h4 id="1-13-1-1-命令行"><a href="#1-13-1-1-命令行" class="headerlink" title="1.13.1.1. 命令行"></a>1.13.1.1. 命令行</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --target ES5 --experimentalDecorators</span><br></pre></td></tr></table></figure>

<h4 id="1-13-1-2-tsconfig-json"><a href="#1-13-1-2-tsconfig-json" class="headerlink" title="1.13.1.2. tsconfig.json"></a>1.13.1.2. tsconfig.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"target"</span>: <span class="string">"ES5"</span>,</span><br><span class="line">        <span class="attr">"experimentalDecorators"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>装饰器</em>是一种特殊类型的声明，它能够被附加到<code>类声明</code>，<code>方法</code>，<code>访问符</code>，<code>属性</code>或<code>参数</code>上。 装饰器使用<code>@expression</code>这种形式，<code>expression</code>求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。</p>
<p>例如，有一个<code>@sealed</code>装饰器，我们会这样定义<code>sealed</code>函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something with "target" ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-2-装饰器工厂"><a href="#1-13-2-装饰器工厂" class="headerlink" title="1.13.2. 装饰器工厂"></a>1.13.2. 装饰器工厂</h3><p>如果我们要定制一个修饰器如何应用到一个声明上，我们得写一个装饰器工厂函数。<em>装饰器工厂</em>就是一个简单的函数，它返回一个表达式，以供装饰器在运行时调用。</p>
<p>我们可以通过下面的方式来写一个装饰器工厂函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">color</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这是一个装饰器工厂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//  这是装饰器</span></span><br><span class="line">        <span class="comment">// do something with "target" and "value"...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-13-3-装饰器组合"><a href="#1-13-3-装饰器组合" class="headerlink" title="1.13.3. 装饰器组合"></a>1.13.3. 装饰器组合</h3><p>多个装饰器可以同时应用到一个声明上，就像下面的示例：</p>
<ul>
<li>书写在同一行上：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@f</span> <span class="meta">@g</span> x</span><br></pre></td></tr></table></figure>

<ul>
<li>书写在多行上：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@f</span></span><br><span class="line"><span class="meta">@g</span></span><br><span class="line">x</span><br></pre></td></tr></table></figure>

<p>当多个装饰器应用于一个声明上，它们求值方式与<a href="http://en.wikipedia.org/wiki/Function_composition" target="_blank" rel="noopener">复合函数</a>相似。在这个模型下，当复合<em>f</em>和<em>g</em>时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于<em>f</em>(<em>g</em>(<em>x</em>))。</p>
<p>同样的，在 TypeScript 里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对装饰器表达式求值。</li>
<li>求值的结果会被当作函数，由下至上依次调用。</li>
</ol>
<p>如果我们使用<code>装饰器工厂</code>的话，可以通过下面的例子来观察它们求值的顺序：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'f(): evaluated'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        target,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'f(): called'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'g(): evaluated'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        target,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'g(): called'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    <span class="meta">@f</span>()</span><br><span class="line">    <span class="meta">@g</span>()</span><br><span class="line">    method() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在控制台里会打印出如下结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(): evaluated</span><br><span class="line">g(): evaluated</span><br><span class="line">g(): called</span><br><span class="line">f(): called</span><br></pre></td></tr></table></figure>

<h3 id="1-13-4-装饰器求值"><a href="#1-13-4-装饰器求值" class="headerlink" title="1.13.4. 装饰器求值"></a>1.13.4. 装饰器求值</h3><p>类中不同声明上的装饰器将按以下规定的顺序应用：</p>
<ol>
<li>_参数装饰器_，然后依次是<em>方法装饰器</em>，_访问符装饰器_，或<em>属性装饰器</em>应用到每个实例成员。</li>
<li>_参数装饰器_，然后依次是<em>方法装饰器</em>，_访问符装饰器_，或<em>属性装饰器</em>应用到每个静态成员。</li>
<li><em>参数装饰器</em>应用到构造函数。</li>
<li><em>类装饰器</em>应用到类。</li>
</ol>
<h3 id="1-13-5-装饰器类别"><a href="#1-13-5-装饰器类别" class="headerlink" title="1.13.5. 装饰器类别"></a>1.13.5. 装饰器类别</h3><h4 id="1-13-5-1-类装饰器"><a href="#1-13-5-1-类装饰器" class="headerlink" title="1.13.5.1. 类装饰器"></a>1.13.5.1. 类装饰器</h4><p><em>类装饰器</em>在类声明之前被声明（紧靠着类声明）。 类装饰器应用于类构造函数，可以用来监视，修改或替换类定义。 类装饰器不能用在声明文件中(<code>.d.ts</code>)，也不能用在任何外部上下文中（比如<code>declare</code>的类）。</p>
<p>类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。</p>
<p>如果类装饰器返回一个值，它会使用提供的构造函数来替换类的声明。</p>
<blockquote>
<p>注意 如果你要返回一个新的构造函数，你必须注意处理好原来的原型链。 在运行时的装饰器调用逻辑中<em>不会</em>为你做这些。</p>
</blockquote>
<p>下面是使用类装饰器(<code>@sealed</code>)的例子，应用在<code>Greeter</code>类：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sealed</span></span><br><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以这样定义<code>@sealed</code>装饰器：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sealed</span>(<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.seal(<span class="keyword">constructor</span>)</span><br><span class="line">    Object.seal(<span class="params">constructor.prototype</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>@sealed</code>被执行的时候，它将密封此类的构造函数和原型。(注：参见<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal" target="_blank" rel="noopener">Object.seal</a>)</p>
<p>下面是一个重载构造函数的例子。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">classDecorator</span>&lt;<span class="title">T</span> <span class="title">extends</span> </span>&#123; <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]): &#123;&#125; &#125;&gt;(</span><br><span class="line">    <span class="keyword">constructor</span>: T</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="keyword">extends</span> <span class="keyword">constructor</span> &#123;</span><br><span class="line">        newProperty = <span class="string">'new property'</span></span><br><span class="line">        hello = <span class="string">'override'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@classDecorator</span></span><br><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    property = <span class="string">'property'</span></span><br><span class="line">    hello: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">m: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hello = m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Greeter(<span class="string">'world'</span>))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;property: <span class="string">"property"</span>, hello: <span class="string">"override"</span>, newProperty: <span class="string">"new property"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-13-5-2-方法装饰器"><a href="#1-13-5-2-方法装饰器" class="headerlink" title="1.13.5.2. 方法装饰器"></a>1.13.5.2. 方法装饰器</h4><p><em>方法装饰器</em>声明在一个方法的声明之前（紧靠着方法声明）。 它会被应用到方法的<em>属性描述符</em>上，可以用来监视，修改或者替换方法定义。 方法装饰器不能用在声明文件(<code>.d.ts</code>)，重载或者任何外部上下文（比如<code>declare</code>的类）中。</p>
<p>方法装饰器表达式会在运行时当作函数被调用，传入下列 3 个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em>。</li>
</ol>
<blockquote>
<p>注意   如果代码输出目标版本小于<code>ES5</code>，<em>属性描述符</em>将会是<code>undefined</code>。</p>
</blockquote>
<p>如果方法装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p>
<blockquote>
<p>注意   如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是一个方法装饰器（<code>@enumerable</code>）的例子，应用于<code>Greeter</code>类的方法上：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@enumerable</span>(<span class="literal">false</span>)</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以用下面的函数声明来定义<code>@enumerable</code>装饰器：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enumerable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        descriptor.enumerable = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的<code>@enumerable(false)</code>是一个<code>装饰器工厂</code>。 当装饰器<code>@enumerable(false)</code>被调用时，它会修改属性描述符的<code>enumerable</code>属性。</p>
<h4 id="1-13-5-3-访问器装饰器"><a href="#1-13-5-3-访问器装饰器" class="headerlink" title="1.13.5.3. 访问器装饰器"></a>1.13.5.3. 访问器装饰器</h4><p><em>访问器装饰器</em>声明在一个访问器的声明之前（紧靠着访问器声明）。 访问器装饰器应用于访问器的<br><em>属性描述符</em>并且可以用来监视，修改或替换一个访问器的定义。 访问器装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如<code>declare</code>的类）里。</p>
<blockquote>
<p>注意   TypeScript 不允许同时装饰一个成员的<code>get</code>和<code>set</code>访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个<em>属性描述符</em>时，它联合了<code>get</code>和<code>set</code>访问器，而不是分开声明的。</p>
</blockquote>
<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列 3 个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em>。</li>
</ol>
<blockquote>
<p>注意   如果代码输出目标版本小于<code>ES5</code>，<em>Property Descriptor</em>将会是<code>undefined</code>。</p>
</blockquote>
<p>如果访问器装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。</p>
<blockquote>
<p>注意   如果代码输出目标版本小于<code>ES5</code>返回值会被忽略。</p>
</blockquote>
<p>下面是使用了访问器装饰器（<code>@configurable</code>）的例子，应用于<code>Point</code>类的成员上：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    <span class="keyword">private</span> _x: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">private</span> _y: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._x = x</span><br><span class="line">        <span class="keyword">this</span>._y = y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">get</span> x() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._x</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">get</span> y() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过如下函数声明来定义<code>@configurable</code>装饰器：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        propertyKey: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">        descriptor: PropertyDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>) </span>&#123;</span><br><span class="line">        descriptor.configurable = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-13-5-4-属性装饰器"><a href="#1-13-5-4-属性装饰器" class="headerlink" title="1.13.5.4. 属性装饰器"></a>1.13.5.4. 属性装饰器</h4><p><em>属性装饰器</em>声明在一个属性声明之前（紧靠着属性声明）。 属性装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如<code>declare</code>的类）里。</p>
<p>属性装饰器表达式会在运行时当作函数被调用，传入下列 2 个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
</ol>
<blockquote>
<p>注意   <em>属性描述符</em>不会做为参数传入属性装饰器，这与 TypeScript 是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>
</blockquote>
<p>我们可以用它来记录这个属性的元数据，如下例所示：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    <span class="meta">@format</span>(<span class="string">'Hello, %s'</span>)</span><br><span class="line">    greeting: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message</span><br><span class="line">    &#125;</span><br><span class="line">    greet() &#123;</span><br><span class="line">        <span class="keyword">let</span> formatString = getFormat(<span class="keyword">this</span>, <span class="string">'greeting'</span>)</span><br><span class="line">        <span class="keyword">return</span> formatString.replace(<span class="string">'%s'</span>, <span class="keyword">this</span>.greeting)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后定义<code>@format</code>装饰器和<code>getFormat</code>函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formatMetadataKey = Symbol(<span class="string">'format'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span>(<span class="params">formatString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Reflect.metadata(formatMetadataKey, formatString)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFormat</span>(<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Reflect.getMetadata(formatMetadataKey, target, propertyKey)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>@format(&quot;Hello, %s&quot;)</code>装饰器是个<code>装饰器工厂</code>。 当<code>@format(&quot;Hello, %s&quot;)</code>被调用时，它添加一条这个属性的元数据，通过<code>reflect-metadata</code>库里的<code>Reflect.metadata</code>函数。当<code>getFormat</code>被调用时，它读取格式的元数据。</p>
<blockquote>
<p>注意   这个例子需要使用<code>reflect-metadata</code>库。</p>
</blockquote>
<h4 id="1-13-5-5-参数装饰器"><a href="#1-13-5-5-参数装饰器" class="headerlink" title="1.13.5.5. 参数装饰器"></a>1.13.5.5. 参数装饰器</h4><p><em>参数装饰器</em>声明在一个参数声明之前（紧靠着参数声明）。 参数装饰器应用于类构造函数或方法声明。 参数装饰器不能用在声明文件（.d.ts），重载或其它外部上下文（比如<code>declare</code>的类）里。</p>
<p>参数装饰器表达式会在运行时当作函数被调用，传入下列 3 个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<blockquote>
<p>注意   参数装饰器只能用来监视一个方法的参数是否被传入。</p>
</blockquote>
<p>参数装饰器的返回值会被忽略。</p>
<p>下例定义了参数装饰器（<code>@required</code>）并应用于<code>Greeter</code>类方法的一个参数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Greeter &#123;</span><br><span class="line">    greeting: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">message: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.greeting = message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@validate</span></span><br><span class="line">    greet(<span class="meta">@required</span> name: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Hello '</span> + name + <span class="string">', '</span> + <span class="keyword">this</span>.greeting</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们使用下面的函数定义 <code>@required</code> 和 <code>@validate</code> 装饰器：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'reflect-metadata'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requiredMetadataKey = Symbol(<span class="string">'required'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">required</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyKey: <span class="built_in">string</span> | symbol,</span></span></span><br><span class="line"><span class="function"><span class="params">    parameterIndex: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> existingRequiredParameters: <span class="built_in">number</span>[] =</span><br><span class="line">        Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || []</span><br><span class="line">    existingRequiredParameters.push(parameterIndex)</span><br><span class="line">    Reflect.defineMetadata(</span><br><span class="line">        requiredMetadataKey,</span><br><span class="line">        existingRequiredParameters,</span><br><span class="line">        target,</span><br><span class="line">        propertyKey</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    propertyName: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    descriptor: TypedPropertyDescriptor&lt;<span class="built_in">Function</span>&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> method = descriptor.value</span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> requiredParameters: <span class="built_in">number</span>[] = Reflect.getOwnMetadata(</span><br><span class="line">            requiredMetadataKey,</span><br><span class="line">            target,</span><br><span class="line">            propertyName</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> (requiredParameters) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> parameterIndex of requiredParameters) &#123;</span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    parameterIndex &gt;= <span class="built_in">arguments</span>.length ||</span><br><span class="line">                    <span class="built_in">arguments</span>[parameterIndex] === <span class="literal">undefined</span></span><br><span class="line">                ) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing required argument.'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> method.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@required</code>装饰器添加了元数据实体把参数标记为必需的。<br><code>@validate</code>装饰器把<code>greet</code>方法包裹在一个函数里在调用原先的函数前验证函数参数。</p>
<blockquote>
<p>注意   这个例子使用了<code>reflect-metadata</code>库。</p>
</blockquote>
<h2 id="1-14-另类特性"><a href="#1-14-另类特性" class="headerlink" title="1.14. 另类特性"></a>1.14. 另类特性</h2><h3 id="1-14-1-柯里化"><a href="#1-14-1-柯里化" class="headerlink" title="1.14.1. 柯里化"></a>1.14.1. 柯里化</h3><p>仅仅需要使用一系列箭头函数：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个柯里化函数</span></span><br><span class="line"><span class="keyword">let</span> add = <span class="function">(<span class="params">x: <span class="built_in">number</span></span>) =&gt;</span> (y: <span class="built_in">number</span>) =&gt; x + y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单使用</span></span><br><span class="line">add(<span class="number">123</span>)(<span class="number">456</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 部分应用</span></span><br><span class="line"><span class="keyword">let</span> add123 = add(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// fully apply the function</span></span><br><span class="line">add123(<span class="number">456</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-14-2-类型转换"><a href="#1-14-2-类型转换" class="headerlink" title="1.14.2. 类型转换"></a>1.14.2. 类型转换</h3><p>在 TypeScript 里，接口可以对符合任一成员类型的对象进行转换，转换之后的对象自动继承了接口的其他成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">    eat(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> thing = &#123; name: <span class="string">'桌子'</span> &#125;</span><br><span class="line"><span class="keyword">let</span> otherThing = &lt;Animal&gt;thing <span class="comment">// 类型转换</span></span><br><span class="line">otherThing.age = <span class="number">5</span></span><br><span class="line">otherThing.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> 不知道吃什么。`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子里，声明了拥有 name 属性的 json 对象，通过&lt;&gt;将 json 对象转换成了 Animal 类型的对象。转换后的对象则拥有了另外的 age 属性和 eat 方法。</p>
<h3 id="1-14-3-接口继承类"><a href="#1-14-3-接口继承类" class="headerlink" title="1.14.3. 接口继承类"></a>1.14.3. 接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的 private 和 protected 成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Control &#123;</span><br><span class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</span><br><span class="line">    select() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-14-4-索引类型查询操作符与索引访问操作符"><a href="#1-14-4-索引类型查询操作符与索引访问操作符" class="headerlink" title="1.14.4. 索引类型查询操作符与索引访问操作符"></a>1.14.4. 索引类型查询操作符与索引访问操作符</h3><p>首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T 的结果为 T 上已知的公共属性名的联合。<br>第二个操作符是 T[K]， 索引访问操作符。 在这里，类型语法反映了表达式语法。 这意味着<code>person[&#39;name&#39;]</code>具有类型<code>Person[&#39;name&#39;]</code> — 在我们的例子里则为 string 类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> strings: (<span class="built_in">string</span> | <span class="built_in">number</span>)[] = pluck(person, [<span class="string">'name'</span>, <span class="string">'age'</span>]) <span class="comment">// ok, (string|number)[]</span></span><br><span class="line"><span class="built_in">console</span>.log(strings) <span class="comment">// [ 'Jarid', 35 ]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在该例子中，<code>T[K]</code>其实相当于<code>(string | number)</code>联合类型，所以<code>T[k][]</code>相当于<code>(string | number)[]</code>了。</p>
</blockquote>
<h3 id="1-14-5-成员默认为public"><a href="#1-14-5-成员默认为public" class="headerlink" title="1.14.5. 成员默认为public"></a>1.14.5. 成员默认为<code>public</code></h3><p>在 TypeScript 里，成员都默认为 public。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'huahua'</span>)</span><br><span class="line">cat.name = <span class="string">'xiaohua'</span></span><br><span class="line">cat.move()</span><br></pre></td></tr></table></figure>

<h3 id="1-14-6-构造函数参数添加了访问修饰符，将会变成类成员"><a href="#1-14-6-构造函数参数添加了访问修饰符，将会变成类成员" class="headerlink" title="1.14.6. 构造函数参数添加了访问修饰符，将会变成类成员"></a>1.14.6. 构造函数参数添加了访问修饰符，将会变成类成员</h3><p>在 TypeScript 里，成员都默认为 public。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">            <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> - <span class="subst">$&#123;<span class="keyword">this</span>.theName&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Animal(<span class="string">'huahua'</span>)</span><br><span class="line">cat.name = <span class="string">'xiaohua'</span></span><br><span class="line">cat.move(<span class="number">20</span>) <span class="comment">// xiaohua - huahua moved 20m.</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.theName) <span class="comment">// huahua</span></span><br></pre></td></tr></table></figure>

<h3 id="1-14-7-参数属性"><a href="#1-14-7-参数属性" class="headerlink" title="1.14.7. 参数属性"></a>1.14.7. 参数属性</h3><p>参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用<code>private</code>限定一个参数属性会声明并初始化一个私有成员；对于<code>public</code>和<code>protected</code>及<code>readonly</code>来说也是一样。</p>
<p>下面的例子在构造函数里使用<code>readonly name: string</code>参数来创建和初始化<code>name</code>成员。 我们把声明和赋值合并至一处。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 章鱼</span></span><br><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，此处的 name 会默认为 public，可以在类定义外访问。</p>
</blockquote>
<h3 id="1-14-8-infer"><a href="#1-14-8-infer" class="headerlink" title="1.14.8. infer"></a>1.14.8. infer</h3><p><code>infer</code> 最早出现在此 <a href="https://github.com/Microsoft/TypeScript/pull/21496" target="_blank" rel="noopener">PR</a> 中，表示在 <code>extends</code> 条件语句中待推断的类型变量。</p>
<p>简单示例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParamType&lt;T&gt; = T <span class="keyword">extends</span> (param: infer P) =&gt; <span class="built_in">any</span> ? P : T <span class="comment">// 其实是 (T extends (param: infer P) =&gt; any) ? P : T</span></span><br></pre></td></tr></table></figure>

<p>在这个条件语句 <code>T extends (param: infer P) =&gt; any ? P : T</code> 中，<code>infer P</code> 表示待推断的函数参数。</p>
<p>整句表示为：如果 <code>T</code> 能赋值给 <code>(param: infer P) =&gt; any</code>，则结果是 <code>(param: infer P) =&gt; any</code> 类型中的参数 <code>P</code>，否则返回为 <code>T</code>。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Func = <span class="function">(<span class="params">user: User</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Param = ParamType&lt;Func&gt; <span class="comment">// Param = User</span></span><br><span class="line"><span class="keyword">type</span> AA = ParamType&lt;<span class="built_in">string</span>&gt; <span class="comment">// AA = string</span></span><br></pre></td></tr></table></figure>

<p>内置类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数返回值类型</span></span><br><span class="line"><span class="keyword">type</span> ReturnType&lt;T&gt; = T <span class="keyword">extends</span> (...args: <span class="built_in">any</span>[]) =&gt; infer P ? P : <span class="built_in">any</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取参数类型</span></span><br><span class="line"><span class="keyword">type</span> ConstructorParameters&lt;</span><br><span class="line">    T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span></span><br><span class="line">&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: infer P) =&gt; <span class="built_in">any</span> ? P : never <span class="comment">// 相当于 (T extends new (...args: infer P) =&gt; any) ? P : never</span></span><br><span class="line"><span class="comment">// 因为`T extends new (...args: any[]) =&gt; any`这个约束，所以不可能返回其他的类型，所以另一个分支为`never`类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例类型</span></span><br><span class="line"><span class="keyword">type</span> InstanceType&lt;T <span class="keyword">extends</span> <span class="keyword">new</span> (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">any</span>&gt; = T <span class="keyword">extends</span> <span class="keyword">new</span> (</span><br><span class="line">    ...args: <span class="built_in">any</span>[]</span><br><span class="line">) =&gt; infer R</span><br><span class="line">    ? R</span><br><span class="line">    : <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>通常用于挖掘函数参数类型或者返回类型。</p>
</blockquote>
<h3 id="1-14-9-Freshness"><a href="#1-14-9-Freshness" class="headerlink" title="1.14.9. Freshness"></a>1.14.9. Freshness</h3><p>为了能让检查对象字面量类型更容易，TypeScript 提供 「Freshness」 的概念（它也被称为更严格的对象字面量检查）用来确保对象字面量在结构上类型兼容。</p>
<h4 id="1-14-9-1-例子一"><a href="#1-14-9-1-例子一" class="headerlink" title="1.14.9.1. 例子一"></a>1.14.9.1. 例子一</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> someThing: &#123; name: <span class="built_in">string</span> &#125;</span><br><span class="line">someThing = &#123; name: <span class="string">'hello'</span> &#125; <span class="comment">// ok</span></span><br><span class="line">someThing = &#123; name: <span class="string">'hello'</span>, age: <span class="number">123</span> &#125; <span class="comment">// Error, 对象字面量只能指定已知属性, &#123; name: string &#125; 类型中不存在 age 属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是赋值却可以，因为fresh消失了，fresh仅仅存在于对象字面赋值</span></span><br><span class="line"><span class="keyword">let</span> otherThing = &#123; name: <span class="string">'hello'</span>, age: <span class="number">123</span> &#125;</span><br><span class="line">someThing = otherThing <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 认为创建的每个对象字面量都是 「 fresh 」 状态；当一个 「 fresh 」 对象字面量赋值给一个变量时，如果对象的类型与变量类型不兼容时，会出现报错（如上例子中 someThine = { name: ‘hello’, age: 123 }; 的错误）；当对象字面量的类型变宽，对象字面量的 「 fresh 」 状态会消失（如上例子中 someThing = otherThing; ，赋值以后，someThing 的类型变宽）。</p>
<h4 id="1-14-9-2-例子二"><a href="#1-14-9-2-例子二" class="headerlink" title="1.14.9.2. 例子二"></a>1.14.9.2. 例子二</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logName</span>(<span class="params">something: &#123; name: <span class="built_in">string</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(something.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logName(&#123; name: <span class="string">'matt'</span> &#125;) <span class="comment">// ok</span></span><br><span class="line">logName(&#123; name: <span class="string">'matt'</span>, job: <span class="string">'being awesome'</span> &#125;) <span class="comment">// Error: 对象字面量只能指定已知属性，`job` 属性在这里并不存在。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解决办法，将参数提取为一个变量传入</span></span><br><span class="line"><span class="keyword">let</span> jack = &#123; name: <span class="string">'matt'</span>, job: <span class="string">'being awesome'</span> &#125;</span><br><span class="line">logName(jack) <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>基本原理与上文中相似，当想用更严格的类型检查时，可以传一个具有 fresh 状态的对象字面量（如 logName({ name: ‘matt’, job: ‘being awesome’ });）。当你想多传一些属性至函数，可以将对象字面量赋值至一个新变量，然后再传至函数（如 logName(obj)）。或者你也可以通过给函数形参添加多余类型的方式 function logName(someThing: { name: string; [key: string]: string })。</p>
<h3 id="1-14-10-鸭式辨型"><a href="#1-14-10-鸭式辨型" class="headerlink" title="1.14.10. 鸭式辨型"></a>1.14.10. 鸭式辨型</h3><p>示例一：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> LabelledValue &#123;</span><br><span class="line">    label: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labelledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(labelledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; size: <span class="number">10</span>, label: <span class="string">'Size 10 Object'</span> &#125;</span><br><span class="line">printLabel(myObj)</span><br></pre></td></tr></table></figure>

<p>示例二：</p>
<p>TypeScript 使用的是<code>结构性类型系统</code>。 当我们比较两种不同的类型时，并不在乎它们从何处而来，<code>如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的</code>。</p>
<p>然而，当我们比较带有<code>private</code>或<code>protected</code>成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个<code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于<code>protected</code>成员也使用这个规则。</p>
<p>下面来看一个例子，更好地说明了这一点：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Rhino'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Goat'</span>)</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino()</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">'Bob'</span>)</span><br><span class="line"></span><br><span class="line">animal = rhino</span><br><span class="line">animal = employee <span class="comment">// 错误: Animal 与 Employee 不兼容，因为name声明来自不同的地方。</span></span><br></pre></td></tr></table></figure>

<p>示例三：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    X,</span><br><span class="line">    Y,</span><br><span class="line">    Z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj: &#123; X: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.X</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works, since 'E' has a property named 'X' which is a number.</span></span><br><span class="line"><span class="keyword">let</span> r = f(E)</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></table></figure>

<h3 id="1-14-11-类型保护"><a href="#1-14-11-类型保护" class="headerlink" title="1.14.11. 类型保护"></a>1.14.11. 类型保护</h3><p>如果一个值是联合类型，那么只能访问联合类型的共有成员。</p>
<p>代码实例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Bird &#123;</span><br><span class="line">    leg = <span class="number">2</span></span><br><span class="line">    color = <span class="string">'white'</span></span><br><span class="line">    fly() &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Insect &#123;</span><br><span class="line">    leg = <span class="number">8</span></span><br><span class="line">    color = <span class="string">'black'</span></span><br><span class="line">    eat() &#123;</span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">antzone</span>(<span class="params"></span>): <span class="title">Bird</span> | <span class="title">Insect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bird()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ant = antzone()</span><br><span class="line">ant.color</span><br><span class="line">ant.leg</span><br><span class="line">ant.eat() <span class="comment">// 报错，只能访问共有成员</span></span><br></pre></td></tr></table></figure>

<p>antzone()函数返回值是联合类型，也就是既有可能是 Bird 类型，也有可能是 Insect 类型。</p>
<p>有时候我们想确切的知道这个返回值到底是属于哪个类型，在原生 JavaScript 中，判断这个非常简单。</p>
<p>只要判断对象是否具有对应属性即可，但是在 TypeScript 可能并不适用，看如下代码实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ant = antzone()</span><br><span class="line"><span class="keyword">if</span> (ant.fly) &#123;</span><br><span class="line">    ant.fly()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ant.eat) &#123;</span><br><span class="line">    ant.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码会报错，因为只能访问联合类型的共有成员；</p>
<p>可以先转换成<code>any</code>类型，然后在判断对应的方法是否存在在执行，代码修改如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ant = antzone()</span><br><span class="line"><span class="keyword">if</span> ((&lt;Bird&gt;ant).fly) &#123;</span><br><span class="line">    ;(&lt;Bird&gt;ant).fly()</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((&lt;Insect&gt;ant).eat) &#123;</span><br><span class="line">    ;(&lt;Insect&gt;ant).eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然使用断言解决此问题，但比较繁琐，if 语句中使用了断言，语句块中还是要断言。</p>
<p>较好的解决方案是，只要判断成功，后面对应作用域中的类型就确定。</p>
<p>TypeScript <code>类型保护机制</code>提供了这样的功能，下面分别做一下介绍。</p>
<h4 id="1-14-11-1-自定义的类型保护"><a href="#1-14-11-1-自定义的类型保护" class="headerlink" title="1.14.11.1. 自定义的类型保护"></a>1.14.11.1. 自定义的类型保护</h4><p>类型保护是一些表达式，它们会检查以确保在某域里的类型。</p>
<p>要定义一个类型保护，只要定义一个函数，它的返回值是一个类型谓词。</p>
<p>代码实例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">ant: Bird | Insect</span>): <span class="title">ant</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Bird&gt;ant).fly !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ant is Bird</code>是一个类型谓词，格式如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameterName is Type</span><br></pre></td></tr></table></figure>

<p>parameterName 必须是当前函数签名里的一个参数名。</p>
<p>如果函数返回值为 true，那么也就意味着<code>类型谓词</code>是成立的，于是它后面作用域的类型也就被固定为 Type。</p>
<p>代码实例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ant = antzone()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBird</span>(<span class="params">ant: Bird | Insect</span>): <span class="title">ant</span> <span class="title">is</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Bird&gt;ant).fly !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isBird(ant)) &#123;</span><br><span class="line">    ant.fly()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ant.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要 isBird(ant)成立，那么它后面作用域中的类型就确定为 Bird。</p>
<h4 id="1-14-11-2-typeof-类型保护"><a href="#1-14-11-2-typeof-类型保护" class="headerlink" title="1.14.11.2. typeof 类型保护"></a>1.14.11.2. typeof 类型保护</h4><p>在 TypeScript 中，typeof 在判断数据类型的同时，直接提供了<code>类型保护</code>功能。</p>
<p>代码实例如下：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ant</span>(<span class="params">param: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">'number'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param + <span class="number">5</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> param === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(param + <span class="string">'蚂蚁部落'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原本是联合类型，由于应用了 typeof，后面作用域的 param 就确定为 number 类型。</p>
<p>typeof 类型保护只有两种形式能被识别：<code>typeof v === &quot;typename</code>和 <code>typeof v !== &quot;typename</code>。</p>
<p>“typename”必须是”number”，”string”，”boolean”或”symbol”。</p>
<p>但是 TypeScript 并不会阻止与其它字符串比较，语言不会把那些表达式识别为类型保护。</p>
<h4 id="1-14-11-3-instanceof-类型保护"><a href="#1-14-11-3-instanceof-类型保护" class="headerlink" title="1.14.11.3. instanceof 类型保护"></a>1.14.11.3. instanceof 类型保护</h4><p>instanceof 的使用方式和 typeof 非常的类似，代码实例如下:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">' '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span></span><br><span class="line">        ? <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>)</span><br><span class="line">        : <span class="keyword">new</span> StringPadder(<span class="string">'  '</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder <span class="comment">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder <span class="comment">// 类型细化为'StringPadder'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-14-11-4-switch-case-类型保护"><a href="#1-14-11-4-switch-case-类型保护" class="headerlink" title="1.14.11.4. switch case 类型保护"></a>1.14.11.4. switch case 类型保护</h4><p>通过 switch case 来实现类型保护，原理都是一样的。</p>
<p>代码实例如下:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">'square'</span></span><br><span class="line">    size: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">'rectangle'</span></span><br><span class="line">    width: <span class="built_in">number</span></span><br><span class="line">    height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">'circle'</span></span><br><span class="line">    radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">shape: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (shape.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.size * shape.size</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">            <span class="keyword">return</span> shape.height * shape.width</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.PI * shape.radius ** <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-14-12-声明合并"><a href="#1-14-12-声明合并" class="headerlink" title="1.14.12. 声明合并"></a>1.14.12. 声明合并</h3><h4 id="1-14-12-1-接口合并"><a href="#1-14-12-1-接口合并" class="headerlink" title="1.14.12.1. 接口合并"></a>1.14.12.1. 接口合并</h4><ul>
<li>接口的非函数的成员应该是唯一的。如果它们不是唯一的，那么它们必须是相同的类型。如果两个接口中同时声明了同名的非函数成员且它们的类型不同，则编译器会报错。</li>
<li>对于函数成员，每个同名函数声明都会被当成这个函数的一个重载。 同时需要注意，当接口 A 与后来的接口 A 合并时，后面的接口具有更高的优先级。</li>
<li>这个规则有一个例外是当出现特殊的函数签名时。 如果签名里有一个参数的类型是 单一的字符串字面量（比如，不是字符串字面量的联合类型），那么它将会被提升到重载列表的最顶端。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">    createElement(tagName: <span class="built_in">any</span>): Element</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">    createElement(tagName: <span class="string">'div'</span>): HTMLDivElement</span><br><span class="line">    createElement(tagName: <span class="string">'span'</span>): HTMLSpanElement</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">    createElement(tagName: <span class="built_in">string</span>): HTMLElement</span><br><span class="line">    createElement(tagName: <span class="string">'canvas'</span>): HTMLCanvasElement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Document &#123;</span><br><span class="line">    createElement(tagName: <span class="string">'canvas'</span>): HTMLCanvasElement</span><br><span class="line">    createElement(tagName: <span class="string">'div'</span>): HTMLDivElement</span><br><span class="line">    createElement(tagName: <span class="string">'span'</span>): HTMLSpanElement</span><br><span class="line">    createElement(tagName: <span class="built_in">string</span>): HTMLElement</span><br><span class="line">    createElement(tagName: <span class="built_in">any</span>): Element</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-14-12-2-命名空间合并"><a href="#1-14-12-2-命名空间合并" class="headerlink" title="1.14.12.2. 命名空间合并"></a>1.14.12.2. 命名空间合并</h4><ul>
<li>对于命名空间的合并，模块导出的同名接口进行合并，构成单一命名空间内含合并后的接口。</li>
<li>对于命名空间里值的合并，如果当前已经存在给定名字的命名空间，那么后来的命名空间的导出成员会被加到已经存在的那个模块里。</li>
<li>非导出成员仅在其原有的（合并前的）命名空间内可见。这就是说合并之后，从其它命名空间合并进来的成员无法访问非导出成员。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">        numberOfLegs: <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animals &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">interface</span> Legged &#123;</span><br><span class="line">        numberOfLegs: <span class="built_in">number</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Zebra &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Dog &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非导出成员其他命名空间无法访问：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">    <span class="keyword">let</span> haveMuscles = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">animalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haveMuscles</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Animal &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">doAnimalsHaveMuscles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> haveMuscles <span class="comment">// Error, because haveMuscles is not accessible here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-14-12-3-命名空间和类合并"><a href="#1-14-12-3-命名空间和类合并" class="headerlink" title="1.14.12.3. 命名空间和类合并"></a>1.14.12.3. 命名空间和类合并</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Album &#123;</span><br><span class="line">    label: Album.AlbumLabel</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Album &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> AlbumLabel &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-14-12-4-命名空间和函数合并"><a href="#1-14-12-4-命名空间和函数合并" class="headerlink" title="1.14.12.4. 命名空间和函数合并"></a>1.14.12.4. 命名空间和函数合并</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLabel</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> buildLabel.prefix + name + buildLabel.suffix</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> buildLabel &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> suffix = <span class="string">''</span></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> prefix = <span class="string">'Hello, '</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(buildLabel(<span class="string">'Sam Smith'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="1-14-12-5-命名空间和枚举合并"><a href="#1-14-12-5-命名空间和枚举合并" class="headerlink" title="1.14.12.5. 命名空间和枚举合并"></a>1.14.12.5. 命名空间和枚举合并</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">    red = <span class="number">1</span>,</span><br><span class="line">    green = <span class="number">2</span>,</span><br><span class="line">    blue = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Color &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixColor</span>(<span class="params">colorName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colorName == <span class="string">'yellow'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red + Color.green</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">'white'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red + Color.green + Color.blue</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (colorName == <span class="string">'magenta'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Color.red + Color.blue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Color.green + Color.blue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-14-13-Mixins（混入）"><a href="#1-14-13-Mixins（混入）" class="headerlink" title="1.14.13. Mixins（混入）"></a>1.14.13. Mixins（混入）</h3><p>除了传统的面向对象继承方式，还流行一种通过可重用组件创建类的方式，就是联合另一个简单类的代码。 你可能在 Scala 等语言里对 mixins 及其特性已经很熟悉了，但它在 JavaScript 中也是很流行的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disposable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Disposable &#123;</span><br><span class="line">    isDisposed: <span class="built_in">boolean</span></span><br><span class="line">    dispose() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isDisposed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activatable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Activatable &#123;</span><br><span class="line">    isActive: <span class="built_in">boolean</span></span><br><span class="line">    activate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    deactivate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SmartObject <span class="keyword">implements</span> Disposable, Activatable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        setInterval(</span><br><span class="line">            () =&gt; <span class="built_in">console</span>.log(<span class="keyword">this</span>.isActive + <span class="string">' : '</span> + <span class="keyword">this</span>.isDisposed),</span><br><span class="line">            <span class="number">500</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interact() &#123;</span><br><span class="line">        <span class="keyword">this</span>.activate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disposable</span></span><br><span class="line">    isDisposed: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    dispose: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    <span class="comment">// Activatable</span></span><br><span class="line">    isActive: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    activate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    deactivate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line">applyMixins(SmartObject, [Disposable, Activatable])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> smartObj = <span class="keyword">new</span> SmartObject()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> smartObj.interact(), <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////////////////////////////////</span></span><br><span class="line"><span class="comment">// In your runtime library somewhere</span></span><br><span class="line"><span class="comment">////////////////////////////////////////</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyMixins</span>(<span class="params">derivedCtor: <span class="built_in">any</span>, baseCtors: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    baseCtors.forEach(<span class="function"><span class="params">baseCtor</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Object</span>.getOwnPropertyNames(baseCtor.prototype).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">            derivedCtor.prototype[name] = baseCtor.prototype[name]</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-15-项目配置"><a href="#1-15-项目配置" class="headerlink" title="1.15. 项目配置"></a>1.15. 项目配置</h2><h3 id="1-15-1-概述"><a href="#1-15-1-概述" class="headerlink" title="1.15.1. 概述"></a>1.15.1. 概述</h3><p>如果一个目录下存在一个<code>tsconfig.json</code>文件，那么它意味着这个目录是 TypeScript 项目的根目。<code>tsconfig.json</code>文件中指定了用来编译这个项目的根文件和编译选项。可以通过<code>tsc --init</code>来生成<code>tsconfig.json</code>文件。</p>
<h3 id="1-15-2-使用-tsconfig-json"><a href="#1-15-2-使用-tsconfig-json" class="headerlink" title="1.15.2. 使用 tsconfig.json"></a>1.15.2. 使用 tsconfig.json</h3><ul>
<li>不带任何输入文件的情况下调用<code>tsc</code>，编译器会从当前目录开始去查找<code>tsconfig.json</code>文件，逐级向上搜索父目录。</li>
<li>不带任何输入文件的情况下调用<code>tsc</code>，且使用命令行参数<code>--project</code>（或<code>-p</code>）指定一个包含<code>tsconfig.json</code>文件的目录。</li>
<li>当命令行上指定了输入文件时，<code>tsconfig.json</code>文件会被忽略。</li>
</ul>
<h3 id="1-15-3-示例"><a href="#1-15-3-示例" class="headerlink" title="1.15.3. 示例"></a>1.15.3. 示例</h3><p><code>tsconfig.json</code>示例文件:</p>
<h4 id="1-15-3-1-使用files属性"><a href="#1-15-3-1-使用files属性" class="headerlink" title="1.15.3.1. 使用files属性"></a>1.15.3.1. 使用<code>files</code>属性</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"commonjs"</span>,</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"preserveConstEnums"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"files"</span>: [</span><br><span class="line">        <span class="string">"core.ts"</span>,</span><br><span class="line">        <span class="string">"sys.ts"</span>,</span><br><span class="line">        <span class="string">"types.ts"</span>,</span><br><span class="line">        <span class="string">"scanner.ts"</span>,</span><br><span class="line">        <span class="string">"parser.ts"</span>,</span><br><span class="line">        <span class="string">"utilities.ts"</span>,</span><br><span class="line">        <span class="string">"binder.ts"</span>,</span><br><span class="line">        <span class="string">"checker.ts"</span>,</span><br><span class="line">        <span class="string">"emitter.ts"</span>,</span><br><span class="line">        <span class="string">"program.ts"</span>,</span><br><span class="line">        <span class="string">"commandLineParser.ts"</span>,</span><br><span class="line">        <span class="string">"tsc.ts"</span>,</span><br><span class="line">        <span class="string">"diagnosticInformationMap.generated.ts"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-15-3-2-使用include和exclude属性"><a href="#1-15-3-2-使用include和exclude属性" class="headerlink" title="1.15.3.2. 使用include和exclude属性"></a>1.15.3.2. 使用<code>include</code>和<code>exclude</code>属性</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"module"</span>: <span class="string">"system"</span>,</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"removeComments"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"preserveConstEnums"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"outFile"</span>: <span class="string">"../../built/local/tsc.js"</span>,</span><br><span class="line">        <span class="attr">"sourceMap"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"include"</span>: [<span class="string">"src/**/*"</span>],</span><br><span class="line">    <span class="attr">"exclude"</span>: [<span class="string">"node_modules"</span>, <span class="string">"**/*.spec.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-15-4-细节"><a href="#1-15-4-细节" class="headerlink" title="1.15.4. 细节"></a>1.15.4. 细节</h3><p><code>compilerOptions</code>可以被忽略，这时编译器会使用默认值。在这里查看完整的<a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener">编译器选项</a>列表。</p>
<p><code>files</code>指定一个包含相对或绝对文件路径的列表。<code>include</code>和<code>exclude</code>属性指定一个文件 glob 匹配模式列表。</p>
<p>支持的 glob 通配符有：</p>
<ul>
<li><code>*</code> 匹配 0 或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
<p>如果一个 glob 模式里的某部分只包含<code>*</code>或<code>.*</code>，那么仅有支持的文件扩展名类型被包含在内（比如默认<code>.ts</code>，<code>.tsx</code>，和<code>.d.ts</code>，如果<code>allowJs</code>设置能<code>true</code>还包含<code>.js</code>和<code>.jsx</code>）。</p>
<p>如果<code>files</code>和<code>include</code>都没有被指定，编译器默认包含当前目录和子目录下所有的 TypeScript 文件（<code>.ts</code>,<code>.d.ts</code> 和 <code>.tsx</code>），排除在<code>exclude</code>里指定的文件。JS 文件（<code>.js</code>和<code>.jsx</code>）也被包含进来如果<code>allowJs</code>被设置成<code>true</code>。<br>如果指定了<code>files</code>或<code>include</code>，编译器会将它们结合一并包含进来。 使用<code>outDir</code>指定的目录下的文件永远会被编译器排除，除非你明确地使用<code>files</code>将其包含进来（这时就算用<code>exclude</code>指定也没用）。</p>
<p>使用<code>include</code>引入的文件可以使用<code>exclude</code>属性过滤。 然而，通过<code>files</code>属性明确指定的文件却总是会被包含在内，不管<code>exclude</code>如何设置。 如果没有特殊指定，<code>exclude</code>默认情况下会排除<code>node_modules</code>，<code>bower_components</code>，<code>jspm_packages</code>和<code>&lt;outDir&gt;</code>目录。</p>
<p>任何被<code>files</code>或<code>include</code>指定的文件所引用的文件也会被包含进来。<code>A.ts</code>引用了<code>B.ts</code>，因此<code>B.ts</code>不能被排除，除非引用它的<code>A.ts</code>在<code>exclude</code>列表中。</p>
<p>需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了<code>index.ts</code>，那么<code>index.d.ts</code>和<code>index.js</code>会被排除在外。<br>通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。</p>
<p><code>tsconfig.json</code>文件可以是个空文件，那么所有默认的文件（如上面所述）都会以默认配置选项编译。</p>
<p>在命令行上指定的编译选项会覆盖在<code>tsconfig.json</code>文件里的相应选项。</p>
<h3 id="1-15-5-types，typeRoots和types"><a href="#1-15-5-types，typeRoots和types" class="headerlink" title="1.15.5. @types，typeRoots和types"></a>1.15.5. <code>@types</code>，<code>typeRoots</code>和<code>types</code></h3><p>默认所有<em>可见的</em><code>@types</code>包会在编译过程中被包含进来。<br><code>node_modules/@types</code>文件夹下以及它们子文件夹下的所有包都是<em>可见的</em>； 也就是说，<code>./node_modules/@types/</code>，<code>../node_modules/@types/</code>和<code>../../node_modules/@types/</code>等等。</p>
<p>如果指定了<code>typeRoots</code>，_只有_<code>typeRoots</code>下面的包才会被包含进来。 比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"typeRoots"</span>: [<span class="string">"./typings"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个配置文件会包含<em>所有</em><code>./typings</code>下面的包，而不包含<code>./node_modules/@types</code>里面的包。</p>
<p>如果指定了<code>types</code>，只有被列出来的包才会被包含进来。 比如：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"types"</span>: [<span class="string">"node"</span>, <span class="string">"lodash"</span>, <span class="string">"express"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>tsconfig.json</code>文件将<em>仅会</em>包含 <code>./node_modules/@types/node</code>，<code>./node_modules/@types/lodash</code>和<code>./node_modules/@types/express</code>。<code>node_modules/@types/*</code>里面的其它包不会被引入进来。</p>
<p>指定<code>types&quot;: []</code>来禁用自动引入<code>@types</code>包。</p>
<p>注意，自动引入只在你使用了全局的声明（相反于模块）时是重要的。 如果你使用<code>import &quot;foo&quot;</code>语句，TypeScript 仍然会查找<code>node_modules</code>和<code>node_modules/@types</code>文件夹来获取<code>foo</code>包。</p>
<h3 id="1-15-6-使用extends继承配置"><a href="#1-15-6-使用extends继承配置" class="headerlink" title="1.15.6. 使用extends继承配置"></a>1.15.6. 使用<code>extends</code>继承配置</h3><p><code>tsconfig.json</code>文件可以利用<code>extends</code>属性从另一个配置文件里继承配置。</p>
<p><code>extends</code>是<code>tsconfig.json</code>文件里的顶级属性（与<code>compilerOptions</code>，<code>files</code>，<code>include</code>，和<code>exclude</code>一样）。<code>extends</code>的值是一个字符串，包含指向另一个要继承文件的路径。</p>
<p>被继承文件里的配置先被加载，然后配置被重写。 如果发现循环引用，则会报错。</p>
<p>来自所继承配置文件的<code>files</code>，<code>include</code>和<code>exclude</code><em>覆盖</em>源配置文件的属性。</p>
<p>配置文件里的相对路径在解析时相对于它所在的文件。</p>
<p>比如：</p>
<p><code>configs/base.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"strictNullChecks"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tsconfig.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"./configs/base"</span>,</span><br><span class="line">    <span class="attr">"files"</span>: [<span class="string">"main.ts"</span>, <span class="string">"supplemental.ts"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tsconfig.nostrictnull.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"extends"</span>: <span class="string">"./tsconfig"</span>,</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"strictNullChecks"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-15-7-compileOnSave"><a href="#1-15-7-compileOnSave" class="headerlink" title="1.15.7. compileOnSave"></a>1.15.7. <code>compileOnSave</code></h3><p>在最顶层设置<code>compileOnSave</code>标记，可以让 IDE 在保存文件的时候根据<code>tsconfig.json</code>重新生成文件。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"compileOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">        <span class="attr">"noImplicitAny"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要想支持这个特性需要 Visual Studio 2015， TypeScript1.8.4 以上并且安装<a href="https://github.com/TypeStrong/atom-typescript#compile-on-save" target="_blank" rel="noopener">atom-typescript</a>插件。</p>
<p>如果是<code>vs code</code> 按<code>ctrl+shift+b</code>或者<code>cmd+shift+b</code>，选择监听命令<code>tsc:watch - tsconfig.json</code>。</p>
<p>或者在命令行输入<code>tsc -p c:\\Users\\gesha_000\\Desktop\\ts-study\\tsconfig.json --watch</code></p>
<h3 id="1-15-8-模式"><a href="#1-15-8-模式" class="headerlink" title="1.15.8. 模式"></a>1.15.8. 模式</h3><p>到这里查看模式: <a href="http://json.schemastore.org/tsconfig." target="_blank" rel="noopener">http://json.schemastore.org/tsconfig.</a></p>
<h2 id="1-16-回顾"><a href="#1-16-回顾" class="headerlink" title="1.16. 回顾"></a>1.16. 回顾</h2><h3 id="1-16-1-extends-amp-implements"><a href="#1-16-1-extends-amp-implements" class="headerlink" title="1.16.1. extends &amp; implements"></a>1.16.1. extends &amp; implements</h3><p><code>extends</code>派生，<code>implements</code>实现。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Animal moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    bark() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Woof! Woof!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.bark()</span><br><span class="line">dog.move(<span class="number">10</span>)</span><br><span class="line">dog.bark()</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span></span><br><span class="line">    setTime(d: <span class="built_in">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockInterface &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span></span><br><span class="line">    setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.currentTime = d</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-2-通过接口创建对象实例"><a href="#1-16-2-通过接口创建对象实例" class="headerlink" title="1.16.2. 通过接口创建对象实例"></a>1.16.2. 通过接口创建对象实例</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    color: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    penWidth: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口继承</span></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    sideLength: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处利用`类型断言`将字面量对象转换为`Square`接口的对象。</span></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;</span><br><span class="line">square.color = <span class="string">'blue'</span></span><br><span class="line">square.sideLength = <span class="number">10</span></span><br><span class="line">square.penWidth = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-3-把类型作为接口implement"><a href="#1-16-3-把类型作为接口implement" class="headerlink" title="1.16.3. 把类型作为接口implement"></a>1.16.3. 把类型作为接口<code>implement</code></h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Disposable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Disposable &#123;</span><br><span class="line">    isDisposed: <span class="built_in">boolean</span></span><br><span class="line">    dispose() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isDisposed = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activatable Mixin</span></span><br><span class="line"><span class="keyword">class</span> Activatable &#123;</span><br><span class="line">    isActive: <span class="built_in">boolean</span></span><br><span class="line">    activate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    deactivate() &#123;</span><br><span class="line">        <span class="keyword">this</span>.isActive = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SmartObject <span class="keyword">implements</span> Disposable, Activatable &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        setInterval(</span><br><span class="line">            () =&gt; <span class="built_in">console</span>.log(<span class="keyword">this</span>.isActive + <span class="string">' : '</span> + <span class="keyword">this</span>.isDisposed),</span><br><span class="line">            <span class="number">500</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    interact() &#123;</span><br><span class="line">        <span class="keyword">this</span>.activate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disposable</span></span><br><span class="line">    isDisposed: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    dispose: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    <span class="comment">// Activatable</span></span><br><span class="line">    isActive: <span class="built_in">boolean</span> = <span class="literal">false</span></span><br><span class="line">    activate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">    deactivate: <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>此时 SmartObject 是包含了 Disposable 和 Activatable 成员的接口类型</p>
</blockquote>
<h3 id="1-16-4-构造器签名接口"><a href="#1-16-4-构造器签名接口" class="headerlink" title="1.16.4. 构造器签名接口"></a>1.16.4. 构造器签名接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器签名定义的接口</span></span><br><span class="line"><span class="keyword">interface</span> ClockConstructor &#123;</span><br><span class="line">    <span class="keyword">new</span> (hour: <span class="built_in">number</span>, minute: <span class="built_in">number</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Clock <span class="keyword">implements</span> ClockConstructor &#123;</span><br><span class="line">    currentTime: <span class="built_in">Date</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">h: <span class="built_in">number</span>, m: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-5-函数接口"><a href="#1-16-5-函数接口" class="headerlink" title="1.16.5. 函数接口"></a>1.16.5. 函数接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SearchFunc &#123;</span><br><span class="line">    (source: <span class="built_in">string</span>, subString: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: <span class="built_in">string</span>, subString: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = source.search(subString)</span><br><span class="line">    <span class="keyword">return</span> result &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-6-索引接口"><a href="#1-16-6-索引接口" class="headerlink" title="1.16.6. 索引接口"></a>1.16.6. 索引接口</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myArray: StringArray</span><br><span class="line">myArray = [<span class="string">'Bob'</span>, <span class="string">'Fred'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myStr: <span class="built_in">string</span> = myArray[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="1-16-7-捕获键的名称"><a href="#1-16-7-捕获键的名称" class="headerlink" title="1.16.7. 捕获键的名称"></a>1.16.7. 捕获键的名称</h3><p><code>keyof</code> 操作符能让你捕获一个类型的键。例如，你可以使用它来捕获变量的键名称，在通过使用 <code>typeof</code> 来获取类型之后：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> colors = &#123;</span><br><span class="line">    red: <span class="string">'red'</span>,</span><br><span class="line">    blue: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Colors = keyof <span class="keyword">typeof</span> colors</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> color: Colors <span class="comment">// color 的类型是 'red' | 'blue'</span></span><br><span class="line">color = <span class="string">'red'</span> <span class="comment">// ok</span></span><br><span class="line">color = <span class="string">'blue'</span> <span class="comment">// ok</span></span><br><span class="line">color = <span class="string">'anythingElse'</span> <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实就是上面的<code>索引类型查询操作符</code>，<code>typeof colors</code>是为了获取类型<code>T</code>，<code>keyof T</code>即使为了获取该类型的索引。</p>
</blockquote>
<h3 id="1-16-8-交叉类型"><a href="#1-16-8-交叉类型" class="headerlink" title="1.16.8. 交叉类型"></a>1.16.8. 交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， <code>Person &amp; Serializable &amp; Loggable</code> 同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        ;(&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            ;(&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">    log(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">'Jim'</span>), <span class="keyword">new</span> ConsoleLogger())</span><br><span class="line"><span class="keyword">var</span> n = jim.name</span><br><span class="line">jim.log()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，上面的示例必须设置编译属性<code>target</code>为<code>es5</code>才可以。</p>
</blockquote>
<h3 id="1-16-9-联合类型"><a href="#1-16-9-联合类型" class="headerlink" title="1.16.9. 联合类型"></a>1.16.9. 联合类型</h3><p>联合类型表示一个值可以是几种类型之一。 我们用竖线（ |）分隔每个类型，所以 <code>number | string | boolean</code> 表示一个值可以是 number， string，或 boolean。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly()</span><br><span class="line">    layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim()</span><br><span class="line">    layEggs()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet()</span><br><span class="line">pet.layEggs() <span class="comment">// okay</span></span><br><span class="line">pet.swim() <span class="comment">// errors</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-10-混合类型"><a href="#1-16-10-混合类型" class="headerlink" title="1.16.10. 混合类型"></a>1.16.10. 混合类型</h3><p>一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Counter &#123;</span><br><span class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">    interval: <span class="built_in">number</span></span><br><span class="line">    reset(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span>(<span class="params">start: <span class="built_in">number</span></span>) </span>&#123;&#125;</span><br><span class="line">    counter.interval = <span class="number">123</span></span><br><span class="line">    counter.reset = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = getCounter()</span><br><span class="line">c(<span class="number">10</span>)</span><br><span class="line">c.reset()</span><br><span class="line">c.interval = <span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-11-映射类型"><a href="#1-16-11-映射类型" class="headerlink" title="1.16.11. 映射类型"></a>1.16.11. 映射类型</h3><p>这在 JavaScript 里经常出现，TypeScript 提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123; readonly [P <span class="keyword">in</span> keyof T]: T[P] &#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;</span><br></pre></td></tr></table></figure>

<p>编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设<code>Person.name</code>是只读的，那么<code>Partial&lt;Person&gt;.name</code>也将是只读的且为可选的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">'option1'</span> | <span class="string">'option2'</span></span><br><span class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">    option1: <span class="built_in">boolean</span></span><br><span class="line">    option2: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-12-类型推断"><a href="#1-16-12-类型推断" class="headerlink" title="1.16.12. 类型推断"></a>1.16.12. 类型推断</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Adder = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iTakeAnAdder</span>(<span class="params">adder: Adder</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adder(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">iTakeAnAdder(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    a = <span class="string">'hello'</span> <span class="comment">// Error: 不能把 'string' 类型赋值给 'number' 类型</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="1-16-13-字面量类型"><a href="#1-16-13-字面量类型" class="headerlink" title="1.16.13. 字面量类型"></a>1.16.13. 字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CardinalDirection = <span class="string">'North'</span> | <span class="string">'East'</span> | <span class="string">'South'</span> | <span class="string">'West'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">distance: <span class="built_in">number</span>, direction: CardinalDirection</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(<span class="number">1</span>, <span class="string">'North'</span>) <span class="comment">// ok</span></span><br><span class="line">move(<span class="number">1</span>, <span class="string">'Nurth'</span>) <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-14-成员属性默认为-public"><a href="#1-16-14-成员属性默认为-public" class="headerlink" title="1.16.14. 成员属性默认为 public"></a>1.16.14. 成员属性默认为 public</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="comment">// 默认为public，c# 默认为private</span></span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">    move(distanceInMeters: <span class="built_in">number</span> = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;distanceInMeters&#125;</span>m.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-15-类型别名"><a href="#1-16-15-类型别名" class="headerlink" title="1.16.15. 类型别名"></a>1.16.15. 类型别名</h3><p>定义一个较短的名词来表示较长的类型定义。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GreetingLike = <span class="built_in">string</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">string</span></span>) | <span class="params">MyGreeter</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">greet</span>(<span class="params">g: GreetingLike</span>): <span class="params">void</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params"><span class="keyword">typeof</span> g === '<span class="built_in">string</span>'</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">console</span>.<span class="params">log</span>(<span class="params">g</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">g <span class="keyword">instanceof</span> <span class="built_in">Function</span></span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">console</span>.<span class="params">log</span>(<span class="params">g(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">    <span class="params">if</span> (<span class="params">g <span class="keyword">instanceof</span> MyGreeter</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">console</span>.<span class="params">log</span>(<span class="params">g.greet(<span class="params"></span>)</span>)</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">function</span> <span class="params">getGreeting</span><span class="params">()</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">return</span> '<span class="params">how</span> <span class="params">are</span> <span class="params">you</span>?'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">MyGreeter</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="params">greet</span><span class="params">()</span>: <span class="params">string</span> &#123;</span></span><br><span class="line"><span class="function">        <span class="params">return</span> '<span class="params">hello</span>'</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">greet</span>(<span class="params">'hi'</span>) // <span class="params">hi</span></span></span><br><span class="line"><span class="function"><span class="params">greet</span>(<span class="params">getGreeting</span>) // <span class="params">how</span> <span class="params">are</span> <span class="params">you</span>?</span></span><br><span class="line"><span class="function"><span class="params">greet</span>(<span class="params"><span class="keyword">new</span> MyGreeter(<span class="params"></span>)</span>) // <span class="params">hello</span></span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-16-类型兼容"><a href="#1-16-16-类型兼容" class="headerlink" title="1.16.16. 类型兼容"></a>1.16.16. 类型兼容</h3><p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 犀牛</span></span><br><span class="line"><span class="keyword">class</span> Rhino <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">'Rhino'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'Goat'</span>)</span><br><span class="line"><span class="keyword">let</span> rhino = <span class="keyword">new</span> Rhino()</span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee(<span class="string">'Bob'</span>)</span><br><span class="line"></span><br><span class="line">animal = rhino</span><br><span class="line">animal = employee <span class="comment">// 错误: Animal 与 Employee 不兼容. name定义不是来自于同一个地方。</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-17-结构化"><a href="#1-16-17-结构化" class="headerlink" title="1.16.17. 结构化"></a>1.16.17. 结构化</h3><p>TypeScript 对象是一种结构类型，这意味着只要结构匹配，名称也就无关紧要了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span></span><br><span class="line">    y: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Point2D &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> x: <span class="built_in">number</span>, <span class="keyword">public</span> y: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Point</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok, 因为是结构化的类型</span></span><br><span class="line">p = <span class="keyword">new</span> Point2D(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-16-18-protected"><a href="#1-16-18-protected" class="headerlink" title="1.16.18. protected"></a>1.16.18. protected</h3><p>构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如，</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">protected</span> name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Employee 能够继承 Person</span></span><br><span class="line"><span class="keyword">class</span> Employee <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">private</span> department: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, department: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name)</span><br><span class="line">        <span class="keyword">this</span>.department = department</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> getElevatorPitch() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`Hello, my name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>.`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> howard = <span class="keyword">new</span> Employee(<span class="string">'Howard'</span>, <span class="string">'Sales'</span>)</span><br><span class="line"><span class="keyword">let</span> john = <span class="keyword">new</span> Person(<span class="string">'John'</span>) <span class="comment">// 错误: 'Person' 的构造函数是被保护的.</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-19-readonly-修饰符"><a href="#1-16-19-readonly-修饰符" class="headerlink" title="1.16.19. readonly 修饰符"></a>1.16.19. readonly 修饰符</h3><p>你可以使用 readonly 关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 章鱼</span></span><br><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span></span><br><span class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">theName: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = theName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> dad = <span class="keyword">new</span> Octopus(<span class="string">'Man with the 8 strong legs'</span>)</span><br><span class="line">dad.name = <span class="string">'Man with the 3-piece suit'</span> <span class="comment">// 错误! name 是只读的.</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">config: &#123; readonly bar: <span class="built_in">number</span>; readonly bas: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123; bar: <span class="number">123</span>, bas: <span class="number">123</span> &#125;</span><br><span class="line">foo(config)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在你能够确保 'config' 不能够被改变了</span></span><br></pre></td></tr></table></figure>

<p>系统预定义的有一个<code>Readonly</code> 的映射类型，它接收一个泛型 <code>T</code>，用来把它的所有属性标记为只读类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Foo = &#123;</span><br><span class="line">    bar: <span class="built_in">number</span></span><br><span class="line">    bas: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FooReadonly = Readonly&lt;Foo&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo: Foo = &#123; bar: <span class="number">123</span>, bas: <span class="number">456</span> &#125;</span><br><span class="line"><span class="keyword">const</span> fooReadonly: FooReadonly = &#123; bar: <span class="number">123</span>, bas: <span class="number">456</span> &#125;</span><br><span class="line"></span><br><span class="line">foo.bar = <span class="number">456</span> <span class="comment">// ok</span></span><br><span class="line">fooReadonly.bar = <span class="number">456</span> <span class="comment">// Error: bar 属性只读</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-20-参数属性"><a href="#1-16-20-参数属性" class="headerlink" title="1.16.20. 参数属性"></a>1.16.20. 参数属性</h3><p>利用参数属性可以将上面的改成如下：把 name 的声明和赋值合并至一处。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 章鱼</span></span><br><span class="line"><span class="keyword">class</span> Octopus &#123;</span><br><span class="line">    readonly numberOfLegs: <span class="built_in">number</span> = <span class="number">8</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> readonly name: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> o = <span class="keyword">new</span> Octopus(<span class="string">'nannan'</span>) <span class="comment">// 注意此处已经完成name的赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(o) <span class="comment">// &#123;name: "nannan", numberOfLegs: 8&#125;</span></span><br><span class="line">o.name = <span class="string">'guoguo'</span> <span class="comment">// error: name is readonly</span></span><br></pre></td></tr></table></figure>

<h3 id="1-16-21-存取器"><a href="#1-16-21-存取器" class="headerlink" title="1.16.21. 存取器"></a>1.16.21. 存取器</h3><p>我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对 fullName 的直接访问改成了可以检查密码的 set 方法。 我们也加了一个 get 方法，让上面的例子仍然可以工作。</p>
<p>注意：首先，存取器要求你将编译器设置为输出 ECMAScript 5 或更高。 不支持降级到 ECMAScript 3。 其次，只带有 get 不带有 set 的存取器自动被推断为 readonly。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> passcode = <span class="string">'secret passcode'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Employee &#123;</span><br><span class="line">    <span class="keyword">private</span> _fullName: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">get</span> fullName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._fullName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">set</span> fullName(newName: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (passcode &amp;&amp; passcode == <span class="string">'secret passcode'</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._fullName = newName</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Error: Unauthorized update of employee!'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employee = <span class="keyword">new</span> Employee()</span><br><span class="line">employee.fullName = <span class="string">'Bob Smith'</span></span><br><span class="line"><span class="keyword">if</span> (employee.fullName) &#123;</span><br><span class="line">    alert(employee.fullName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-22-抽象类"><a href="#1-16-22-抽象类" class="headerlink" title="1.16.22. 抽象类"></a>1.16.22. 抽象类</h3><p>抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract 关键字是用于定义抽象类和在抽象类内部定义抽象方法。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal &#123;</span><br><span class="line">    <span class="keyword">abstract</span> makeSound(): <span class="built_in">void</span></span><br><span class="line">    move(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'roaming the earch...'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-16-23-泛型对象字面量"><a href="#1-16-23-泛型对象字面量" class="headerlink" title="1.16.23. 泛型对象字面量"></a>1.16.23. 泛型对象字面量</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123; &lt;T&gt;(arg: T): T &#125; = identity</span><br></pre></td></tr></table></figure>

<h3 id="1-16-24-泛型接口"><a href="#1-16-24-泛型接口" class="headerlink" title="1.16.24. 泛型接口"></a>1.16.24. 泛型接口</h3><p>注意，无法创建泛型枚举和泛型命名空间。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity</span><br></pre></td></tr></table></figure>

<h3 id="1-16-25-常数枚举表达式"><a href="#1-16-25-常数枚举表达式" class="headerlink" title="1.16.25. 常数枚举表达式"></a>1.16.25. 常数枚举表达式</h3><p>常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p>
<ul>
<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>
<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）<br>带括号的常量枚举表达式</li>
<li>一元运算符 +, -, ~其中之一应用在了常量枚举表达式</li>
<li>常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">    Red = <span class="number">1</span>,</span><br><span class="line">    Green = <span class="number">2</span>,</span><br><span class="line">    Blue = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = Color.Red</span><br><span class="line"><span class="keyword">let</span> y = Color.Red + Color.Blue</span><br></pre></td></tr></table></figure>

<p>编译后的 js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span> <span class="comment">/* Red */</span></span><br><span class="line"><span class="keyword">let</span> y = <span class="number">1</span> <span class="comment">/* Red */</span> + <span class="number">3</span> <span class="comment">/* Blue */</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/typescript/" rel="tag"># typescript</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/10/07/axure/Axure-RP-9-%E6%B3%A8%E5%86%8C%E7%A0%81/" rel="prev" title="Axure RP 9 注册码">
      <i class="fa fa-chevron-left"></i> Axure RP 9 注册码
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/10/12/ts/jsdoc%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="jsdoc学习笔记">
      jsdoc学习笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-要点"><span class="nav-number">1.</span> <span class="nav-text">1. 要点</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-为什么要使用"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 为什么要使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-基础类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. 基础类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-布尔值"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1. 布尔值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-数字"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2. 数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-字符串"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3. 字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-数组"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4. 数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5-元组-Tuple"><span class="nav-number">1.2.5.</span> <span class="nav-text">1.2.5. 元组 Tuple</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6-Any"><span class="nav-number">1.2.6.</span> <span class="nav-text">1.2.6. Any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-7-Void"><span class="nav-number">1.2.7.</span> <span class="nav-text">1.2.7. Void</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-8-Null-和-Undefined"><span class="nav-number">1.2.8.</span> <span class="nav-text">1.2.8. Null 和 Undefined</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-9-Never"><span class="nav-number">1.2.9.</span> <span class="nav-text">1.2.9. Never</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-10-Object"><span class="nav-number">1.2.10.</span> <span class="nav-text">1.2.10. Object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-11-Symbol"><span class="nav-number">1.2.11.</span> <span class="nav-text">1.2.11. Symbol</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Enum-枚举"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. Enum 枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-数字枚举"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. 数字枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-字符串枚举"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 字符串枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-异构枚举"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3. 异构枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-联合枚举与枚举成员的类型"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4. 联合枚举与枚举成员的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-反向映射"><span class="nav-number">1.3.5.</span> <span class="nav-text">1.3.5. 反向映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-6-常量枚举"><span class="nav-number">1.3.6.</span> <span class="nav-text">1.3.6. 常量枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Interface-接口"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. Interface 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-简单类型"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. 简单类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-函数类型"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2. 函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-可索引的类型"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3. 可索引的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-4-类接口"><span class="nav-number">1.4.4.</span> <span class="nav-text">1.4.4. 类接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-5-接口继承"><span class="nav-number">1.4.5.</span> <span class="nav-text">1.4.5. 接口继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-6-混合类型"><span class="nav-number">1.4.6.</span> <span class="nav-text">1.4.6. 混合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-7-接口重载"><span class="nav-number">1.4.7.</span> <span class="nav-text">1.4.7. 接口重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Class-类"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. Class 类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-基本例子"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. 基本例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-继承"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-private"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-4-protected"><span class="nav-number">1.5.4.</span> <span class="nav-text">1.5.4. protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-5-readonly"><span class="nav-number">1.5.5.</span> <span class="nav-text">1.5.5. readonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-6-存取器"><span class="nav-number">1.5.6.</span> <span class="nav-text">1.5.6. 存取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-7-静态属性"><span class="nav-number">1.5.7.</span> <span class="nav-text">1.5.7. 静态属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-8-抽象类"><span class="nav-number">1.5.8.</span> <span class="nav-text">1.5.8. 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-9-用-typescript-实现多态"><span class="nav-number">1.5.9.</span> <span class="nav-text">1.5.9. 用 typescript 实现多态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-函数"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-函数类型"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-可选参数和默认参数"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 可选参数和默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-剩余参数"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. 剩余参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-4-函数重载"><span class="nav-number">1.6.4.</span> <span class="nav-text">1.6.4. 函数重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-迭代器"><span class="nav-number">1.7.</span> <span class="nav-text">1.7. 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-for-of-语句"><span class="nav-number">1.7.1.</span> <span class="nav-text">1.7.1. for..of 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-for-in-语句"><span class="nav-number">1.7.2.</span> <span class="nav-text">1.7.2. for..in 语句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3-for-of-vs-for-in-语句"><span class="nav-number">1.7.3.</span> <span class="nav-text">1.7.3. for..of vs. for..in 语句</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-泛型"><span class="nav-number">1.8.</span> <span class="nav-text">1.8. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-1-泛型定义"><span class="nav-number">1.8.1.</span> <span class="nav-text">1.8.1. 泛型定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-2-泛型类型"><span class="nav-number">1.8.2.</span> <span class="nav-text">1.8.2. 泛型类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-2-1-常规声明方式"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">1.8.2.1. 常规声明方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-2-2-泛型接口声明方式"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">1.8.2.2. 泛型接口声明方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-8-2-3-对象字面量声明方式"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">1.8.2.3. 对象字面量声明方式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-3-泛型类"><span class="nav-number">1.8.3.</span> <span class="nav-text">1.8.3. 泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-4-泛型约束"><span class="nav-number">1.8.4.</span> <span class="nav-text">1.8.4. 泛型约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-高级类型"><span class="nav-number">1.9.</span> <span class="nav-text">1.9. 高级类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-1-交叉类型（Intersection-Types）"><span class="nav-number">1.9.1.</span> <span class="nav-text">1.9.1. 交叉类型（Intersection Types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-2-联合类型（Union-Types）"><span class="nav-number">1.9.2.</span> <span class="nav-text">1.9.2. 联合类型（Union Types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-3-null-类型"><span class="nav-number">1.9.3.</span> <span class="nav-text">1.9.3. null 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-1-null和undefined-赋值"><span class="nav-number">1.9.3.1.</span> <span class="nav-text">1.9.3.1. null和undefined 赋值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-2-可选参数和可选属性"><span class="nav-number">1.9.3.2.</span> <span class="nav-text">1.9.3.2. 可选参数和可选属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-3-3-类型保护和类型断言"><span class="nav-number">1.9.3.3.</span> <span class="nav-text">1.9.3.3. 类型保护和类型断言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-4-类型别名"><span class="nav-number">1.9.4.</span> <span class="nav-text">1.9.4. 类型别名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-1-常规用法"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">1.9.4.1. 常规用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-4-2-接口-vs-类型别名"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">1.9.4.2. 接口 vs. 类型别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-5-字符串字面量类型"><span class="nav-number">1.9.5.</span> <span class="nav-text">1.9.5. 字符串字面量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-6-数字字面量类型"><span class="nav-number">1.9.6.</span> <span class="nav-text">1.9.6. 数字字面量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-7-枚举成员类型"><span class="nav-number">1.9.7.</span> <span class="nav-text">1.9.7. 枚举成员类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-8-可辨识联合（Discriminated-Unions）"><span class="nav-number">1.9.8.</span> <span class="nav-text">1.9.8. 可辨识联合（Discriminated Unions）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-9-多态的this类型"><span class="nav-number">1.9.9.</span> <span class="nav-text">1.9.9. 多态的this类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-10-索引类型（Index-types）"><span class="nav-number">1.9.10.</span> <span class="nav-text">1.9.10. 索引类型（Index types）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-10-1-索引类型查询操作符和索引访问操作符"><span class="nav-number">1.9.10.1.</span> <span class="nav-text">1.9.10.1. 索引类型查询操作符和索引访问操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-9-10-2-索引类型和字符串索引签名"><span class="nav-number">1.9.10.2.</span> <span class="nav-text">1.9.10.2. 索引类型和字符串索引签名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-9-11-映射类型"><span class="nav-number">1.9.11.</span> <span class="nav-text">1.9.11. 映射类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-模块"><span class="nav-number">1.10.</span> <span class="nav-text">1.10. 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-1-内部模块和外部模块"><span class="nav-number">1.10.1.</span> <span class="nav-text">1.10.1. 内部模块和外部模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-2-外部模块"><span class="nav-number">1.10.2.</span> <span class="nav-text">1.10.2. 外部模块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-3-导出"><span class="nav-number">1.10.3.</span> <span class="nav-text">1.10.3. 导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-1-导出声明"><span class="nav-number">1.10.3.1.</span> <span class="nav-text">1.10.3.1. 导出声明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-3-1-1-Validation-ts"><span class="nav-number">1.10.3.1.1.</span> <span class="nav-text">1.10.3.1.1. Validation.ts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-3-1-2-ZipCodeValidator-ts"><span class="nav-number">1.10.3.1.2.</span> <span class="nav-text">1.10.3.1.2. ZipCodeValidator.ts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-2-导出语句"><span class="nav-number">1.10.3.2.</span> <span class="nav-text">1.10.3.2. 导出语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-3-3-重新导出"><span class="nav-number">1.10.3.3.</span> <span class="nav-text">1.10.3.3. 重新导出</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-3-3-1-ParseIntBasedZipCodeValidator-ts"><span class="nav-number">1.10.3.3.1.</span> <span class="nav-text">1.10.3.3.1. ParseIntBasedZipCodeValidator.ts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-3-3-2-AllValidators-ts"><span class="nav-number">1.10.3.3.2.</span> <span class="nav-text">1.10.3.3.2. AllValidators.ts</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-4-导入"><span class="nav-number">1.10.4.</span> <span class="nav-text">1.10.4. 导入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-4-1-导入一个模块中的某个导出内容"><span class="nav-number">1.10.4.1.</span> <span class="nav-text">1.10.4.1. 导入一个模块中的某个导出内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-4-2-将整个模块导入到一个变量，并通过它来访问模块的导出部分"><span class="nav-number">1.10.4.2.</span> <span class="nav-text">1.10.4.2. 将整个模块导入到一个变量，并通过它来访问模块的导出部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-4-3-具有副作用的导入模块"><span class="nav-number">1.10.4.3.</span> <span class="nav-text">1.10.4.3. 具有副作用的导入模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-5-默认导出"><span class="nav-number">1.10.5.</span> <span class="nav-text">1.10.5. 默认导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-1-导出类"><span class="nav-number">1.10.5.1.</span> <span class="nav-text">1.10.5.1. 导出类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-5-1-1-ZipCodeValidator-ts"><span class="nav-number">1.10.5.1.1.</span> <span class="nav-text">1.10.5.1.1. ZipCodeValidator.ts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-5-1-2-Test1-ts"><span class="nav-number">1.10.5.1.2.</span> <span class="nav-text">1.10.5.1.2. Test1.ts</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-2-导出函数"><span class="nav-number">1.10.5.2.</span> <span class="nav-text">1.10.5.2. 导出函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-3-StaticZipCodeValidator-ts"><span class="nav-number">1.10.5.3.</span> <span class="nav-text">1.10.5.3. StaticZipCodeValidator.ts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-4-Test2-ts"><span class="nav-number">1.10.5.4.</span> <span class="nav-text">1.10.5.4. Test2.ts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-5-5-导出一个值"><span class="nav-number">1.10.5.5.</span> <span class="nav-text">1.10.5.5. 导出一个值</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-5-5-1-OneTwoThree-ts"><span class="nav-number">1.10.5.5.1.</span> <span class="nav-text">1.10.5.5.1. OneTwoThree.ts</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-5-5-2-Log-ts"><span class="nav-number">1.10.5.5.2.</span> <span class="nav-text">1.10.5.5.2. Log.ts</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-6-模块解析"><span class="nav-number">1.10.6.</span> <span class="nav-text">1.10.6. 模块解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-6-1-相对-vs-非相对模块导入"><span class="nav-number">1.10.6.1.</span> <span class="nav-text">1.10.6.1. 相对 vs. 非相对模块导入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-7-模块解析策略"><span class="nav-number">1.10.7.</span> <span class="nav-text">1.10.7. 模块解析策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-7-1-Classic"><span class="nav-number">1.10.7.1.</span> <span class="nav-text">1.10.7.1. Classic</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-1-1-相对模块导入"><span class="nav-number">1.10.7.1.1.</span> <span class="nav-text">1.10.7.1.1. 相对模块导入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-1-2-非相对模块导入"><span class="nav-number">1.10.7.1.2.</span> <span class="nav-text">1.10.7.1.2. 非相对模块导入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-7-2-Node"><span class="nav-number">1.10.7.2.</span> <span class="nav-text">1.10.7.2. Node</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-2-1-相对路径"><span class="nav-number">1.10.7.2.1.</span> <span class="nav-text">1.10.7.2.1. 相对路径</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-2-2-非相对路径"><span class="nav-number">1.10.7.2.2.</span> <span class="nav-text">1.10.7.2.2. 非相对路径</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-10-7-3-TypeScript"><span class="nav-number">1.10.7.3.</span> <span class="nav-text">1.10.7.3. TypeScript</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-3-1-相对导入"><span class="nav-number">1.10.7.3.1.</span> <span class="nav-text">1.10.7.3.1. 相对导入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-10-7-3-2-非相对导入"><span class="nav-number">1.10.7.3.2.</span> <span class="nav-text">1.10.7.3.2. 非相对导入</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11-TSX"><span class="nav-number">1.11.</span> <span class="nav-text">1.11. TSX</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-1-基本用法"><span class="nav-number">1.11.1.</span> <span class="nav-text">1.11.1. 基本用法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-2-as操作符"><span class="nav-number">1.11.2.</span> <span class="nav-text">1.11.2. as操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-3-类型检查"><span class="nav-number">1.11.3.</span> <span class="nav-text">1.11.3. 类型检查</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-3-1-固有元素"><span class="nav-number">1.11.3.1.</span> <span class="nav-text">1.11.3.1. 固有元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-11-3-2-基于值的元素"><span class="nav-number">1.11.3.2.</span> <span class="nav-text">1.11.3.2. 基于值的元素</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-命名空间"><span class="nav-number">1.12.</span> <span class="nav-text">1.12. 命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-1-单文件命名空间"><span class="nav-number">1.12.1.</span> <span class="nav-text">1.12.1. 单文件命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-1-1-TestAll-ts"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">1.12.1.1. TestAll.ts</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-2-多文件中的命名空间"><span class="nav-number">1.12.2.</span> <span class="nav-text">1.12.2. 多文件中的命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-1-Validation-ts"><span class="nav-number">1.12.2.1.</span> <span class="nav-text">1.12.2.1. Validation.ts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-2-LettersOnlyValidator-ts"><span class="nav-number">1.12.2.2.</span> <span class="nav-text">1.12.2.2. LettersOnlyValidator.ts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-3-ZipCodeValidator-ts"><span class="nav-number">1.12.2.3.</span> <span class="nav-text">1.12.2.3. ZipCodeValidator.ts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-12-2-4-Test-ts"><span class="nav-number">1.12.2.4.</span> <span class="nav-text">1.12.2.4. Test.ts</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-12-3-别名"><span class="nav-number">1.12.3.</span> <span class="nav-text">1.12.3. 别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-装饰器"><span class="nav-number">1.13.</span> <span class="nav-text">1.13. 装饰器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-1-编译器配置"><span class="nav-number">1.13.1.</span> <span class="nav-text">1.13.1. 编译器配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-1-1-命令行"><span class="nav-number">1.13.1.1.</span> <span class="nav-text">1.13.1.1. 命令行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-1-2-tsconfig-json"><span class="nav-number">1.13.1.2.</span> <span class="nav-text">1.13.1.2. tsconfig.json</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-2-装饰器工厂"><span class="nav-number">1.13.2.</span> <span class="nav-text">1.13.2. 装饰器工厂</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-3-装饰器组合"><span class="nav-number">1.13.3.</span> <span class="nav-text">1.13.3. 装饰器组合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-4-装饰器求值"><span class="nav-number">1.13.4.</span> <span class="nav-text">1.13.4. 装饰器求值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-13-5-装饰器类别"><span class="nav-number">1.13.5.</span> <span class="nav-text">1.13.5. 装饰器类别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-5-1-类装饰器"><span class="nav-number">1.13.5.1.</span> <span class="nav-text">1.13.5.1. 类装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-5-2-方法装饰器"><span class="nav-number">1.13.5.2.</span> <span class="nav-text">1.13.5.2. 方法装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-5-3-访问器装饰器"><span class="nav-number">1.13.5.3.</span> <span class="nav-text">1.13.5.3. 访问器装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-5-4-属性装饰器"><span class="nav-number">1.13.5.4.</span> <span class="nav-text">1.13.5.4. 属性装饰器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-13-5-5-参数装饰器"><span class="nav-number">1.13.5.5.</span> <span class="nav-text">1.13.5.5. 参数装饰器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-14-另类特性"><span class="nav-number">1.14.</span> <span class="nav-text">1.14. 另类特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-1-柯里化"><span class="nav-number">1.14.1.</span> <span class="nav-text">1.14.1. 柯里化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-2-类型转换"><span class="nav-number">1.14.2.</span> <span class="nav-text">1.14.2. 类型转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-3-接口继承类"><span class="nav-number">1.14.3.</span> <span class="nav-text">1.14.3. 接口继承类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-4-索引类型查询操作符与索引访问操作符"><span class="nav-number">1.14.4.</span> <span class="nav-text">1.14.4. 索引类型查询操作符与索引访问操作符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-5-成员默认为public"><span class="nav-number">1.14.5.</span> <span class="nav-text">1.14.5. 成员默认为public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-6-构造函数参数添加了访问修饰符，将会变成类成员"><span class="nav-number">1.14.6.</span> <span class="nav-text">1.14.6. 构造函数参数添加了访问修饰符，将会变成类成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-7-参数属性"><span class="nav-number">1.14.7.</span> <span class="nav-text">1.14.7. 参数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-8-infer"><span class="nav-number">1.14.8.</span> <span class="nav-text">1.14.8. infer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-9-Freshness"><span class="nav-number">1.14.9.</span> <span class="nav-text">1.14.9. Freshness</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-9-1-例子一"><span class="nav-number">1.14.9.1.</span> <span class="nav-text">1.14.9.1. 例子一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-9-2-例子二"><span class="nav-number">1.14.9.2.</span> <span class="nav-text">1.14.9.2. 例子二</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-10-鸭式辨型"><span class="nav-number">1.14.10.</span> <span class="nav-text">1.14.10. 鸭式辨型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-11-类型保护"><span class="nav-number">1.14.11.</span> <span class="nav-text">1.14.11. 类型保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-11-1-自定义的类型保护"><span class="nav-number">1.14.11.1.</span> <span class="nav-text">1.14.11.1. 自定义的类型保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-11-2-typeof-类型保护"><span class="nav-number">1.14.11.2.</span> <span class="nav-text">1.14.11.2. typeof 类型保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-11-3-instanceof-类型保护"><span class="nav-number">1.14.11.3.</span> <span class="nav-text">1.14.11.3. instanceof 类型保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-11-4-switch-case-类型保护"><span class="nav-number">1.14.11.4.</span> <span class="nav-text">1.14.11.4. switch case 类型保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-12-声明合并"><span class="nav-number">1.14.12.</span> <span class="nav-text">1.14.12. 声明合并</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-12-1-接口合并"><span class="nav-number">1.14.12.1.</span> <span class="nav-text">1.14.12.1. 接口合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-12-2-命名空间合并"><span class="nav-number">1.14.12.2.</span> <span class="nav-text">1.14.12.2. 命名空间合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-12-3-命名空间和类合并"><span class="nav-number">1.14.12.3.</span> <span class="nav-text">1.14.12.3. 命名空间和类合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-12-4-命名空间和函数合并"><span class="nav-number">1.14.12.4.</span> <span class="nav-text">1.14.12.4. 命名空间和函数合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-14-12-5-命名空间和枚举合并"><span class="nav-number">1.14.12.5.</span> <span class="nav-text">1.14.12.5. 命名空间和枚举合并</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-14-13-Mixins（混入）"><span class="nav-number">1.14.13.</span> <span class="nav-text">1.14.13. Mixins（混入）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-15-项目配置"><span class="nav-number">1.15.</span> <span class="nav-text">1.15. 项目配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-1-概述"><span class="nav-number">1.15.1.</span> <span class="nav-text">1.15.1. 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-2-使用-tsconfig-json"><span class="nav-number">1.15.2.</span> <span class="nav-text">1.15.2. 使用 tsconfig.json</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-3-示例"><span class="nav-number">1.15.3.</span> <span class="nav-text">1.15.3. 示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-3-1-使用files属性"><span class="nav-number">1.15.3.1.</span> <span class="nav-text">1.15.3.1. 使用files属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-15-3-2-使用include和exclude属性"><span class="nav-number">1.15.3.2.</span> <span class="nav-text">1.15.3.2. 使用include和exclude属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-4-细节"><span class="nav-number">1.15.4.</span> <span class="nav-text">1.15.4. 细节</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-5-types，typeRoots和types"><span class="nav-number">1.15.5.</span> <span class="nav-text">1.15.5. @types，typeRoots和types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-6-使用extends继承配置"><span class="nav-number">1.15.6.</span> <span class="nav-text">1.15.6. 使用extends继承配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-7-compileOnSave"><span class="nav-number">1.15.7.</span> <span class="nav-text">1.15.7. compileOnSave</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-15-8-模式"><span class="nav-number">1.15.8.</span> <span class="nav-text">1.15.8. 模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-16-回顾"><span class="nav-number">1.16.</span> <span class="nav-text">1.16. 回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-1-extends-amp-implements"><span class="nav-number">1.16.1.</span> <span class="nav-text">1.16.1. extends &amp; implements</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-2-通过接口创建对象实例"><span class="nav-number">1.16.2.</span> <span class="nav-text">1.16.2. 通过接口创建对象实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-3-把类型作为接口implement"><span class="nav-number">1.16.3.</span> <span class="nav-text">1.16.3. 把类型作为接口implement</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-4-构造器签名接口"><span class="nav-number">1.16.4.</span> <span class="nav-text">1.16.4. 构造器签名接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-5-函数接口"><span class="nav-number">1.16.5.</span> <span class="nav-text">1.16.5. 函数接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-6-索引接口"><span class="nav-number">1.16.6.</span> <span class="nav-text">1.16.6. 索引接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-7-捕获键的名称"><span class="nav-number">1.16.7.</span> <span class="nav-text">1.16.7. 捕获键的名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-8-交叉类型"><span class="nav-number">1.16.8.</span> <span class="nav-text">1.16.8. 交叉类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-9-联合类型"><span class="nav-number">1.16.9.</span> <span class="nav-text">1.16.9. 联合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-10-混合类型"><span class="nav-number">1.16.10.</span> <span class="nav-text">1.16.10. 混合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-11-映射类型"><span class="nav-number">1.16.11.</span> <span class="nav-text">1.16.11. 映射类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-12-类型推断"><span class="nav-number">1.16.12.</span> <span class="nav-text">1.16.12. 类型推断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-13-字面量类型"><span class="nav-number">1.16.13.</span> <span class="nav-text">1.16.13. 字面量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-14-成员属性默认为-public"><span class="nav-number">1.16.14.</span> <span class="nav-text">1.16.14. 成员属性默认为 public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-15-类型别名"><span class="nav-number">1.16.15.</span> <span class="nav-text">1.16.15. 类型别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-16-类型兼容"><span class="nav-number">1.16.16.</span> <span class="nav-text">1.16.16. 类型兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-17-结构化"><span class="nav-number">1.16.17.</span> <span class="nav-text">1.16.17. 结构化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-18-protected"><span class="nav-number">1.16.18.</span> <span class="nav-text">1.16.18. protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-19-readonly-修饰符"><span class="nav-number">1.16.19.</span> <span class="nav-text">1.16.19. readonly 修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-20-参数属性"><span class="nav-number">1.16.20.</span> <span class="nav-text">1.16.20. 参数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-21-存取器"><span class="nav-number">1.16.21.</span> <span class="nav-text">1.16.21. 存取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-22-抽象类"><span class="nav-number">1.16.22.</span> <span class="nav-text">1.16.22. 抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-23-泛型对象字面量"><span class="nav-number">1.16.23.</span> <span class="nav-text">1.16.23. 泛型对象字面量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-24-泛型接口"><span class="nav-number">1.16.24.</span> <span class="nav-text">1.16.24. 泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-16-25-常数枚举表达式"><span class="nav-number">1.16.25.</span> <span class="nav-text">1.16.25. 常数枚举表达式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Andy Ge</p>
  <div class="site-description" itemprop="description">勇于积极进取，步入人生的世外桃源</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">728</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">134</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">315</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/andyge" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;andyge" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:geshaofei@126.com" title="E-Mail → mailto:geshaofei@126.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;" rel="noopener" target="_blank">阮一峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://colobu.com/" title="http:&#x2F;&#x2F;colobu.com&#x2F;" rel="noopener" target="_blank">鸟窝</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.cnblogs.com/hellokuangshen/" title="https:&#x2F;&#x2F;www.cnblogs.com&#x2F;hellokuangshen&#x2F;" rel="noopener" target="_blank">狂神</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://yelog.org/" title="https:&#x2F;&#x2F;yelog.org&#x2F;" rel="noopener" target="_blank">叶落阁</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Andy Ge</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v7.7.1
  </div>

        






  <script>
  function leancloudSelector(url) {
    url = encodeURI(url);
    return document.getElementById(url).querySelector('.leancloud-visitors-count');
  }
  if (CONFIG.page.isPost) {
    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.getAttribute('id'));
      var title = visitors.getAttribute('data-flag-title');

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .then(response => response.json())
              .then(() => {
                leancloudSelector(url).innerText = counter.time + 1;
              })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              })
          } else {
              Counter('post', '/classes/Counter', { title: title, url: url, time: 1 })
                .then(response => response.json())
                .then(() => {
                  leancloudSelector(url).innerText = 1;
                })
                .catch(error => {
                  console.error('Failed to create', error);
                });
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  } else {
    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.getAttribute('id'));
      });

      Counter('get', `/classes/Counter?where=${JSON.stringify({ url: { '$in': entries } })}`)
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length === 0) {
            document.querySelectorAll('.leancloud_visitors .leancloud-visitors-count').forEach(element => {
              element.innerText = 0;
            });
            return;
          }
          for (let item of results) {
            let { url, time } = item;
            leancloudSelector(url).innerText = time;
          }
          for (let url of entries) {
            var element = leancloudSelector(url);
            if (element.innerText == '') {
              element.innerText = 0;
            }
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }
  }

  fetch('https://app-router.leancloud.cn/2/route?appId=2TdIb5gRlAVUw24l2W0zWnCj-gzGzoHsz')
    .then(response => response.json())
    .then(({ api_server }) => {
      var Counter = (method, url, data) => {
        return fetch(`https://${api_server}/1.1${url}`, {
          method: method,
          headers: {
            'X-LC-Id'     : '2TdIb5gRlAVUw24l2W0zWnCj-gzGzoHsz',
            'X-LC-Key'    : 'cJdJrMLBXsj0ttq0WsL0aA2j',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    });
  </script>


      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
